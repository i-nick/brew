# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prism` gem.
# Please instead update this file by running `bin/tapioca gem prism`.


# typed: strict

# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism/dsl.rbi.erb
# if you are looking to modify the template
# =end
# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism/node.rbi.erb
# if you are looking to modify the template
# =end
# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism/visitor.rbi.erb
# if you are looking to modify the template
# =end

# We keep these shims in here because our client libraries might not have parser
# in their bundle.
module Parser; end

class Parser::Base; end

module Prism
  class << self
    def dump(*_arg0); end
    def dump_file(*_arg0); end
    def lex(*_arg0); end

    sig { params(source: String, options: T::Hash[Symbol, T.untyped]).returns(Prism::LexCompat::Result) }
    def lex_compat(source, **options); end

    def lex_file(*_arg0); end

    sig { params(source: String).returns(T::Array[T.untyped]) }
    def lex_ripper(source); end

    sig { params(source: String, serialized: String, freeze: T.nilable(T::Boolean)).returns(Prism::ParseResult) }
    def load(source, serialized, freeze = T.unsafe(nil)); end

    def parse(*_arg0); end
    def parse_comments(*_arg0); end
    def parse_failure?(*_arg0); end
    def parse_file(*_arg0); end
    def parse_file_comments(*_arg0); end
    def parse_file_failure?(*_arg0); end
    def parse_file_success?(*_arg0); end
    def parse_lex(*_arg0); end
    def parse_lex_file(*_arg0); end
    def parse_stream(*_arg0); end
    def parse_success?(*_arg0); end
    def profile(*_arg0); end
    def profile_file(*_arg0); end

    sig { params(locals: T::Array[Symbol], forwarding: T::Array[Symbol]).returns(Prism::Scope) }
    def scope(locals: T.unsafe(nil), forwarding: T.unsafe(nil)); end
  end
end

class Prism::ASCIISource < ::Prism::Source
  sig { params(byte_offset: Integer).returns(Integer) }
  def character_column(byte_offset); end

  sig { params(byte_offset: Integer).returns(Integer) }
  def character_offset(byte_offset); end

  sig do
    params(
      encoding: Encoding
    ).returns(T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer)))
  end
  def code_units_cache(encoding); end

  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_column(byte_offset, encoding); end

  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_offset(byte_offset, encoding); end
end

class Prism::AliasGlobalVariableNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode),
      old_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, new_name, old_name, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode),
      old_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasGlobalVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)) }
  def new_name; end

  sig do
    returns(T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode))
  end
  def old_name; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::AliasMethodNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode),
      old_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, new_name, old_name, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode),
      old_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasMethodNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)) }
  def new_name; end

  sig do
    returns(T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode))
  end
  def old_name; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::AlternationPatternNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AlternationPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def right; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::AndNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AndNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def right; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ArgumentsNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T::Array[Prism::Node]
    ).void
  end
  def initialize(source, node_id, location, flags, arguments); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Array[Prism::Node]) }
  def arguments; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T::Boolean) }
  def contains_forwarding?; end

  sig { returns(T::Boolean) }
  def contains_keyword_splat?; end

  sig { returns(T::Boolean) }
  def contains_keywords?; end

  sig { returns(T::Boolean) }
  def contains_multiple_splats?; end

  sig { returns(T::Boolean) }
  def contains_splat?; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T::Array[Prism::Node]
    ).returns(Prism::ArgumentsNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for arguments nodes.
module Prism::ArgumentsNodeFlags; end

Prism::ArgumentsNodeFlags::CONTAINS_FORWARDING = T.let(T.unsafe(nil), Integer)
Prism::ArgumentsNodeFlags::CONTAINS_KEYWORDS = T.let(T.unsafe(nil), Integer)
Prism::ArgumentsNodeFlags::CONTAINS_KEYWORD_SPLAT = T.let(T.unsafe(nil), Integer)
Prism::ArgumentsNodeFlags::CONTAINS_MULTIPLE_SPLATS = T.let(T.unsafe(nil), Integer)
Prism::ArgumentsNodeFlags::CONTAINS_SPLAT = T.let(T.unsafe(nil), Integer)

class Prism::ArrayNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, elements, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T::Boolean) }
  def contains_splat?; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for array nodes.
module Prism::ArrayNodeFlags; end

Prism::ArrayNodeFlags::CONTAINS_SPLAT = T.let(T.unsafe(nil), Integer)

class Prism::ArrayPatternNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, constant, requireds, rest, posts, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode))) }
  def constant; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::AssocNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, key, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location)
    ).returns(Prism::AssocNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Prism::Node) }
  def key; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::AssocSplatNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::AssocSplatNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(T.nilable(Prism::Node)) }
  def value; end

  class << self
    def type; end
  end
end

Prism::BACKEND = T.let(T.unsafe(nil), Symbol)

class Prism::BackReferenceReadNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BackReferenceReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BasicVisitor
  sig { params(node: T.nilable(Prism::Node)).void }
  def visit(node); end

  sig { params(nodes: T::Array[T.nilable(Prism::Node)]).void }
  def visit_all(nodes); end

  sig { params(node: Prism::Node).void }
  def visit_child_nodes(node); end
end

class Prism::BeginNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(String)) }
  def begin_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def begin_keyword_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::BeginNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { returns(T.nilable(Prism::EnsureNode)) }
  def ensure_clause; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  def newline_flag!(lines); end

  sig { returns(T.nilable(Prism::RescueNode)) }
  def rescue_clause; end

  def save_begin_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BlockArgumentNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, expression, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::BlockArgumentNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BlockLocalVariableNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BlockLocalVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BlockNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, locals, parameters, body, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::BlockNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode))) }
  def parameters; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BlockParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::BlockParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BlockParametersNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::BlockLocalVariableNode],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, parameters, locals, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::BlockLocalVariableNode],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::BlockParametersNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Prism::BlockLocalVariableNode]) }
  def locals; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::BreakNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, arguments, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::BreakNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::CallAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Symbol) }
  def read_name; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_call_operator_loc(repository); end
  def save_message_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  sig { returns(Symbol) }
  def write_name; end

  class << self
    def type; end
  end
end

class Prism::CallNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::CallNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T.nilable(Prism::Location)) }
  def full_message_loc; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_call_operator_loc(repository); end
  def save_closing_loc(repository); end
  def save_message_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    def type; end
  end
end

# Flags for call nodes.
module Prism::CallNodeFlags; end

Prism::CallNodeFlags::ATTRIBUTE_WRITE = T.let(T.unsafe(nil), Integer)
Prism::CallNodeFlags::IGNORE_VISIBILITY = T.let(T.unsafe(nil), Integer)
Prism::CallNodeFlags::SAFE_NAVIGATION = T.let(T.unsafe(nil), Integer)
Prism::CallNodeFlags::VARIABLE_CALL = T.let(T.unsafe(nil), Integer)

class Prism::CallOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, binary_operator, binary_operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  def operator; end
  def operator_loc; end

  sig { returns(Symbol) }
  def read_name; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_binary_operator_loc(repository); end
  def save_call_operator_loc(repository); end
  def save_message_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  sig { returns(Symbol) }
  def write_name; end

  class << self
    def type; end
  end
end

class Prism::CallOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Symbol) }
  def read_name; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_call_operator_loc(repository); end
  def save_message_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  sig { returns(Symbol) }
  def write_name; end

  class << self
    def type; end
  end
end

class Prism::CallTargetNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, name, message_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(String) }
  def call_operator; end

  sig { returns(Prism::Location) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location
    ).returns(Prism::CallTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def message; end

  sig { returns(Prism::Location) }
  def message_loc; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Node) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_call_operator_loc(repository); end
  def save_message_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    def type; end
  end
end

class Prism::CapturePatternNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      target: Prism::LocalVariableTargetNode,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, target, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      target: Prism::LocalVariableTargetNode,
      operator_loc: Prism::Location
    ).returns(Prism::CapturePatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { returns(Prism::LocalVariableTargetNode) }
  def target; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::CaseMatchNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::InNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, predicate, conditions, else_clause, case_keyword_loc, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(String) }
  def case_keyword; end

  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T::Array[Prism::InNode]) }
  def conditions; end

  def consequent; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::InNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseMatchNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  def save_case_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::CaseNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::WhenNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, predicate, conditions, else_clause, case_keyword_loc, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(String) }
  def case_keyword; end

  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T::Array[Prism::WhenNode]) }
  def conditions; end

  def consequent; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::WhenNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  def save_case_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ClassNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode),
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def class_keyword; end

  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode)) }
  def constant_path; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode),
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ClassNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T.nilable(String)) }
  def inheritance_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def inheritance_operator_loc; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(Symbol) }
  def name; end

  def save_class_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end
  def save_inheritance_operator_loc(repository); end

  sig { returns(T.nilable(Prism::Node)) }
  def superclass; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ClassVariableAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ClassVariableOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ClassVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  def operator; end
  def operator_loc; end
  def save_binary_operator_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ClassVariableOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ClassVariableReadNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ClassVariableTargetNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ClassVariableWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ClassVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::CodeUnitsCache
  sig { params(source: String, encoding: Encoding).void }
  def initialize(source, encoding); end

  sig { params(byte_offset: Integer).returns(Integer) }
  def [](byte_offset); end
end

class Prism::CodeUnitsCache::LengthCounter
  def initialize(source, encoding); end

  def count(byte_offset, byte_length); end
end

class Prism::CodeUnitsCache::UTF16Counter
  def initialize(source, encoding); end

  def count(byte_offset, byte_length); end
end

class Prism::Comment
  abstract!

  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Prism::Location) }
  def location; end

  sig { returns(String) }
  def slice; end

  sig { abstract.returns(T::Boolean) }
  def trailing?; end
end

class Prism::Compiler < ::Prism::Visitor
  sig { params(node: T.nilable(Prism::Node)).returns(T.untyped) }
  def visit(node); end

  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end

  sig { params(nodes: T::Array[T.nilable(Prism::Node)]).returns(T::Array[T.untyped]) }
  def visit_all(nodes); end

  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end

  sig { params(node: Prism::Node).returns(T::Array[T.untyped]) }
  def visit_child_nodes(node); end

  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end
end

class Prism::ConstantAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  def operator; end
  def operator_loc; end
  def save_binary_operator_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantPathAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantPathNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, parent, name, delimiter_loc, name_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  def child; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def delimiter; end

  sig { returns(Prism::Location) }
  def delimiter_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def full_name; end

  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  def save_delimiter_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ConstantPathNode::DynamicPartsInConstantPathError < ::StandardError; end
class Prism::ConstantPathNode::MissingNodesInConstantPathError < ::StandardError; end

class Prism::ConstantPathOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, target, binary_operator_loc, value, binary_operator); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantPathOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  def operator; end
  def operator_loc; end
  def save_binary_operator_loc(repository); end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantPathOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantPathTargetNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, parent, name, delimiter_loc, name_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  def child; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def delimiter; end

  sig { returns(Prism::Location) }
  def delimiter_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def full_name; end

  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  def save_delimiter_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ConstantPathWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ConstantReadNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def full_name; end

  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ConstantTargetNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def full_name; end

  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ConstantWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ConstantWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def full_name; end

  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::CurrentVersionError < ::ArgumentError
  def initialize(version); end
end

module Prism::DSL
  extend ::Prism::DSL

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode),
      old_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasGlobalVariableNode)
  end
  def alias_global_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode),
      old_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasMethodNode)
  end
  def alias_method_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AlternationPatternNode)
  end
  def alternation_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AndNode)
  end
  def and_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T::Array[Prism::Node]
    ).returns(Prism::ArgumentsNode)
  end
  def arguments_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def arguments_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayNode)
  end
  def array_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def array_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayPatternNode)
  end
  def array_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location)
    ).returns(Prism::AssocNode)
  end
  def assoc_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::AssocSplatNode)
  end
  def assoc_splat_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BackReferenceReadNode)
  end
  def back_reference_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::BeginNode)
  end
  def begin_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::BlockArgumentNode)
  end
  def block_argument_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BlockLocalVariableNode)
  end
  def block_local_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::BlockNode)
  end
  def block_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::BlockParameterNode)
  end
  def block_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::BlockLocalVariableNode],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::BlockParametersNode)
  end
  def block_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::BreakNode)
  end
  def break_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallAndWriteNode)
  end
  def call_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::CallNode)
  end
  def call_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def call_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOperatorWriteNode)
  end
  def call_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOrWriteNode)
  end
  def call_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location
    ).returns(Prism::CallTargetNode)
  end
  def call_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      target: Prism::LocalVariableTargetNode,
      operator_loc: Prism::Location
    ).returns(Prism::CapturePatternNode)
  end
  def capture_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::InNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseMatchNode)
  end
  def case_match_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::WhenNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseNode)
  end
  def case_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode),
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ClassNode)
  end
  def class_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableAndWriteNode)
  end
  def class_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ClassVariableOperatorWriteNode)
  end
  def class_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableOrWriteNode)
  end
  def class_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableReadNode)
  end
  def class_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableTargetNode)
  end
  def class_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ClassVariableWriteNode)
  end
  def class_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantAndWriteNode)
  end
  def constant_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantOperatorWriteNode)
  end
  def constant_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantOrWriteNode)
  end
  def constant_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathAndWriteNode)
  end
  def constant_path_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathNode)
  end
  def constant_path_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantPathOperatorWriteNode)
  end
  def constant_path_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathOrWriteNode)
  end
  def constant_path_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathTargetNode)
  end
  def constant_path_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathWriteNode)
  end
  def constant_path_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantReadNode)
  end
  def constant_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantTargetNode)
  end
  def constant_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ConstantWriteNode)
  end
  def constant_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::DefNode)
  end
  def def_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location
    ).returns(Prism::DefinedNode)
  end
  def defined_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::ElseNode)
  end
  def else_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location
    ).returns(Prism::EmbeddedStatementsNode)
  end
  def embedded_statements_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      variable: T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)
    ).returns(Prism::EmbeddedVariableNode)
  end
  def embedded_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), variable: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def encoding_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location
    ).returns(Prism::EnsureNode)
  end
  def ensure_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::FalseNode)
  end
  def false_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      left: Prism::SplatNode,
      requireds: T::Array[Prism::Node],
      right: T.any(Prism::SplatNode, Prism::MissingNode),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::FindPatternNode)
  end
  def find_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::FlipFlopNode)
  end
  def flip_flop_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Float
    ).returns(Prism::FloatNode)
  end
  def float_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      index: T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode),
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location
    ).returns(Prism::ForNode)
  end
  def for_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ForwardingArgumentsNode)
  end
  def forwarding_arguments_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ForwardingParameterNode)
  end
  def forwarding_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      block: T.nilable(Prism::BlockNode)
    ).returns(Prism::ForwardingSuperNode)
  end
  def forwarding_super_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), block: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableAndWriteNode)
  end
  def global_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::GlobalVariableOperatorWriteNode)
  end
  def global_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableOrWriteNode)
  end
  def global_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableReadNode)
  end
  def global_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableTargetNode)
  end
  def global_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::GlobalVariableWriteNode)
  end
  def global_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)],
      closing_loc: Prism::Location
    ).returns(Prism::HashNode)
  end
  def hash_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      elements: T::Array[Prism::AssocNode],
      rest: T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode)),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::HashPatternNode)
  end
  def hash_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(T.any(Prism::ElseNode, Prism::IfNode)),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::IfNode)
  end
  def if_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numeric: T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)
    ).returns(Prism::ImaginaryNode)
  end
  def imaginary_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numeric: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode)
    ).returns(Prism::ImplicitNode)
  end
  def implicit_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ImplicitRestNode)
  end
  def implicit_rest_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location)
    ).returns(Prism::InNode)
  end
  def in_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexAndWriteNode)
  end
  def index_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOperatorWriteNode)
  end
  def index_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOrWriteNode)
  end
  def index_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode)
    ).returns(Prism::IndexTargetNode)
  end
  def index_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableAndWriteNode)
  end
  def instance_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::InstanceVariableOperatorWriteNode)
  end
  def instance_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableOrWriteNode)
  end
  def instance_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableReadNode)
  end
  def instance_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableTargetNode)
  end
  def instance_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::InstanceVariableWriteNode)
  end
  def instance_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def integer_base_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Integer
    ).returns(Prism::IntegerNode)
  end
  def integer_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedMatchLastLineNode)
  end
  def interpolated_match_last_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedRegularExpressionNode)
  end
  def interpolated_regular_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedStringNode)
  end
  def interpolated_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def interpolated_string_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedSymbolNode)
  end
  def interpolated_symbol_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedXStringNode)
  end
  def interpolated_x_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ItLocalVariableReadNode)
  end
  def it_local_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ItParametersNode)
  end
  def it_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]
    ).returns(Prism::KeywordHashNode)
  end
  def keyword_hash_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def keyword_hash_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::KeywordRestParameterNode)
  end
  def keyword_rest_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))
    ).returns(Prism::LambdaNode)
  end
  def lambda_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableAndWriteNode)
  end
  def local_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      binary_operator: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOperatorWriteNode)
  end
  def local_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), binary_operator: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOrWriteNode)
  end
  def local_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableReadNode)
  end
  def local_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableTargetNode)
  end
  def local_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::LocalVariableWriteNode)
  end
  def local_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).returns(Prism::Location) }
  def location(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def loop_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::MatchLastLineNode)
  end
  def match_last_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchPredicateNode)
  end
  def match_predicate_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchRequiredNode)
  end
  def match_required_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      call: Prism::CallNode,
      targets: T::Array[Prism::LocalVariableTargetNode]
    ).returns(Prism::MatchWriteNode)
  end
  def match_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), call: T.unsafe(nil), targets: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::MissingNode)
  end
  def missing_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ModuleNode)
  end
  def module_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::MultiTargetNode)
  end
  def multi_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::MultiWriteNode)
  end
  def multi_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::NextNode)
  end
  def next_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::NilNode)
  end
  def nil_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location
    ).returns(Prism::NoKeywordsParameterNode)
  end
  def no_keywords_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      maximum: Integer
    ).returns(Prism::NumberedParametersNode)
  end
  def numbered_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), maximum: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      number: Integer
    ).returns(Prism::NumberedReferenceReadNode)
  end
  def numbered_reference_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), number: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalKeywordParameterNode)
  end
  def optional_keyword_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalParameterNode)
  end
  def optional_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::OrNode)
  end
  def or_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def parameter_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      requireds: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)],
      optionals: T::Array[Prism::OptionalParameterNode],
      rest: T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode)),
      posts: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)],
      keywords: T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)],
      keyword_rest: T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)),
      block: T.nilable(Prism::BlockParameterNode)
    ).returns(Prism::ParametersNode)
  end
  def parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::ParenthesesNode)
  end
  def parentheses_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def parentheses_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location
    ).returns(Prism::PinnedExpressionNode)
  end
  def pinned_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      variable: T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode),
      operator_loc: Prism::Location
    ).returns(Prism::PinnedVariableNode)
  end
  def pinned_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), variable: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PostExecutionNode)
  end
  def post_execution_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PreExecutionNode)
  end
  def pre_execution_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode
    ).returns(Prism::ProgramNode)
  end
  def program_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def range_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::RangeNode)
  end
  def range_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numerator: Integer,
      denominator: Integer
    ).returns(Prism::RationalNode)
  end
  def rational_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numerator: T.unsafe(nil), denominator: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::RedoNode)
  end
  def redo_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def regular_expression_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::RegularExpressionNode)
  end
  def regular_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location
    ).returns(Prism::RequiredKeywordParameterNode)
  end
  def required_keyword_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::RequiredParameterNode)
  end
  def required_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node
    ).returns(Prism::RescueModifierNode)
  end
  def rescue_modifier_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)),
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(Prism::RescueNode)
    ).returns(Prism::RescueNode)
  end
  def rescue_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::RestParameterNode)
  end
  def rest_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::RetryNode)
  end
  def retry_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode)
    ).returns(Prism::ReturnNode)
  end
  def return_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::SelfNode)
  end
  def self_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      write: T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode)
    ).returns(Prism::ShareableConstantNode)
  end
  def shareable_constant_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), write: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def shareable_constant_node_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location
    ).returns(Prism::SingletonClassNode)
  end
  def singleton_class_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { params(string: String).returns(Prism::Source) }
  def source(string); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::SourceEncodingNode)
  end
  def source_encoding_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      filepath: String
    ).returns(Prism::SourceFileNode)
  end
  def source_file_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), filepath: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::SourceLineNode)
  end
  def source_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node)
    ).returns(Prism::SplatNode)
  end
  def splat_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T::Array[Prism::Node]
    ).returns(Prism::StatementsNode)
  end
  def statements_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def string_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::StringNode)
  end
  def string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::SuperNode)
  end
  def super_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { params(name: Symbol).returns(Integer) }
  def symbol_flag(name); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::SymbolNode)
  end
  def symbol_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::TrueNode)
  end
  def true_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      names: T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      keyword_loc: Prism::Location
    ).returns(Prism::UndefNode)
  end
  def undef_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), names: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      else_clause: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::UnlessNode)
  end
  def unless_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), else_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::UntilNode)
  end
  def until_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhenNode)
  end
  def when_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhileNode)
  end
  def while_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::XStringNode)
  end
  def x_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::YieldNode)
  end
  def yield_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  private

  sig { returns(Prism::Location) }
  def default_location; end

  sig { params(source: Prism::Source, location: Prism::Location).returns(Prism::Node) }
  def default_node(source, location); end

  sig { returns(Prism::Source) }
  def default_source; end
end

class Prism::DefNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::DefNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def def_keyword; end

  sig { returns(Prism::Location) }
  def def_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def equal; end

  sig { returns(T.nilable(Prism::Location)) }
  def equal_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  def save_def_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end
  def save_equal_loc(repository); end
  def save_lparen_loc(repository); end
  def save_name_loc(repository); end
  def save_operator_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::DefinedNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, lparen_loc, value, rparen_loc, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location
    ).returns(Prism::DefinedNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  def save_keyword_loc(repository); end
  def save_lparen_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::DesugarAndWriteNode
  include ::Prism::DSL

  def initialize(node, default_source, read_class, write_class, **arguments); end

  def arguments; end
  def compile; end
  def default_source; end
  def node; end
  def read_class; end
  def write_class; end
end

class Prism::DesugarCompiler < ::Prism::MutationCompiler
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
end

class Prism::DesugarOperatorWriteNode
  include ::Prism::DSL

  def initialize(node, default_source, read_class, write_class, **arguments); end

  def arguments; end
  def compile; end
  def default_source; end
  def node; end
  def read_class; end
  def write_class; end
end

class Prism::DesugarOrWriteDefinedNode
  include ::Prism::DSL

  def initialize(node, default_source, read_class, write_class, **arguments); end

  def arguments; end
  def compile; end
  def default_source; end
  def node; end
  def read_class; end
  def write_class; end
end

class Prism::DesugarOrWriteNode
  include ::Prism::DSL

  def initialize(node, default_source, read_class, write_class, **arguments); end

  def arguments; end
  def compile; end
  def default_source; end
  def node; end
  def read_class; end
  def write_class; end
end

class Prism::Dispatcher < ::Prism::Visitor
  def initialize; end

  def dispatch(node); end
  def dispatch_once(node); end
  def listeners; end
  def register(listener, *events); end
  def register_public_methods(listener); end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end

  private

  def register_events(listener, events); end
end

class Prism::Dispatcher::DispatchOnce < ::Prism::Visitor
  def initialize(listeners); end

  def listeners; end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end
end

class Prism::DotVisitor < ::Prism::Visitor
  def initialize; end

  def digraph; end
  def to_dot; end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end

  private

  def arguments_node_flags_inspect(node); end
  def array_node_flags_inspect(node); end
  def call_node_flags_inspect(node); end
  def encoding_flags_inspect(node); end
  def integer_base_flags_inspect(node); end
  def interpolated_string_node_flags_inspect(node); end
  def keyword_hash_node_flags_inspect(node); end
  def location_inspect(location); end
  def loop_flags_inspect(node); end
  def node_id(node); end
  def parameter_flags_inspect(node); end
  def parentheses_node_flags_inspect(node); end
  def range_flags_inspect(node); end
  def regular_expression_flags_inspect(node); end
  def shareable_constant_node_flags_inspect(node); end
  def string_flags_inspect(node); end
  def symbol_flags_inspect(node); end
end

class Prism::DotVisitor::Digraph
  def initialize; end

  def edge(value); end
  def edges; end
  def node(value); end
  def nodes; end
  def to_dot; end
  def waypoint(value); end
  def waypoints; end
end

class Prism::DotVisitor::Field
  def initialize(name, value, port); end

  def name; end
  def port; end
  def to_dot; end
  def value; end
end

class Prism::DotVisitor::Table
  def initialize(name); end

  def field(name, value = T.unsafe(nil), port: T.unsafe(nil)); end
  def fields; end
  def name; end
  def to_dot; end
end

class Prism::ElseNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, else_keyword_loc, statements, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::ElseNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def else_keyword; end

  sig { returns(Prism::Location) }
  def else_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  def save_else_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::EmbDocComment < ::Prism::Comment
  sig { returns(String) }
  def inspect; end

  sig { override.returns(T::Boolean) }
  def trailing?; end
end

class Prism::EmbeddedStatementsNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, statements, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location
    ).returns(Prism::EmbeddedStatementsNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::EmbeddedVariableNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      variable: T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)
    ).void
  end
  def initialize(source, node_id, location, flags, operator_loc, variable); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      variable: T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)
    ).returns(Prism::EmbeddedVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), variable: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig do
    returns(T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode))
  end
  def variable; end

  class << self
    def type; end
  end
end

# Flags for nodes that have unescaped content.
module Prism::EncodingFlags; end

Prism::EncodingFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::EncodingFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

class Prism::EnsureNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, ensure_keyword_loc, statements, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location
    ).returns(Prism::EnsureNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { returns(String) }
  def ensure_keyword; end

  sig { returns(Prism::Location) }
  def ensure_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  def save_end_keyword_loc(repository); end
  def save_ensure_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::FalseNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::FalseNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::FindPatternNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      left: Prism::SplatNode,
      requireds: T::Array[Prism::Node],
      right: T.any(Prism::SplatNode, Prism::MissingNode),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, constant, left, requireds, right, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode))) }
  def constant; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      left: Prism::SplatNode,
      requireds: T::Array[Prism::Node],
      right: T.any(Prism::SplatNode, Prism::MissingNode),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::FindPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Prism::SplatNode) }
  def left; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  sig { returns(T.any(Prism::SplatNode, Prism::MissingNode)) }
  def right; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::FlipFlopNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::FlipFlopNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def exclude_end?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::FloatNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, value: Float).void }
  def initialize(source, node_id, location, flags, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer, value: Float).returns(Prism::FloatNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Float) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ForNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      index: T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode),
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(Prism::Node) }
  def collection; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      index: T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode),
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location
    ).returns(Prism::ForNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def do_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def for_keyword; end

  sig { returns(Prism::Location) }
  def for_keyword_loc; end

  sig { returns(String) }
  def in_keyword; end

  sig { returns(Prism::Location) }
  def in_keyword_loc; end

  sig do
    returns(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode))
  end
  def index; end

  sig { override.returns(String) }
  def inspect; end

  def save_do_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end
  def save_for_keyword_loc(repository); end
  def save_in_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ForwardingArgumentsNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ForwardingArgumentsNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ForwardingParameterNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ForwardingParameterNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ForwardingSuperNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      block: T.nilable(Prism::BlockNode)
    ).void
  end
  def initialize(source, node_id, location, flags, block); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::BlockNode)) }
  def block; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      block: T.nilable(Prism::BlockNode)
    ).returns(Prism::ForwardingSuperNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::GlobalVariableAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::GlobalVariableOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::GlobalVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  def operator; end
  def operator_loc; end
  def save_binary_operator_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::GlobalVariableOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::GlobalVariableReadNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::GlobalVariableTargetNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::GlobalVariableWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::GlobalVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::HashNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, elements, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)],
      closing_loc: Prism::Location
    ).returns(Prism::HashNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::HashPatternNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      elements: T::Array[Prism::AssocNode],
      rest: T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode)),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, constant, elements, rest, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode))) }
  def constant; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      elements: T::Array[Prism::AssocNode],
      rest: T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode)),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::HashPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::AssocNode]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode))) }
  def rest; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

module Prism::HeredocQuery
  def heredoc?; end
end

class Prism::IfNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(T.any(Prism::ElseNode, Prism::IfNode)),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, if_keyword_loc, predicate, then_keyword_loc, statements, subsequent, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  def consequent; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(T.any(Prism::ElseNode, Prism::IfNode)),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::IfNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T.nilable(String)) }
  def if_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def if_keyword_loc; end

  sig { override.returns(String) }
  def inspect; end

  def newline_flag!(lines); end

  sig { returns(Prism::Node) }
  def predicate; end

  def save_end_keyword_loc(repository); end
  def save_if_keyword_loc(repository); end
  def save_then_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(T.any(Prism::ElseNode, Prism::IfNode))) }
  def subsequent; end

  sig { returns(T.nilable(String)) }
  def then_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ImaginaryNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numeric: T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)
    ).void
  end
  def initialize(source, node_id, location, flags, numeric); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numeric: T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)
    ).returns(Prism::ImaginaryNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numeric: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)) }
  def numeric; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Complex) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::ImplicitNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode)
    ).void
  end
  def initialize(source, node_id, location, flags, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode)
    ).returns(Prism::ImplicitNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  sig do
    returns(T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode))
  end
  def value; end

  class << self
    def type; end
  end
end

class Prism::ImplicitRestNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ImplicitRestNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::InNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, pattern, statements, in_loc, then_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location)
    ).returns(Prism::InNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def in; end

  sig { returns(Prism::Location) }
  def in_loc; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Prism::Node) }
  def pattern; end

  def save_in_loc(repository); end
  def save_then_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(String)) }
  def then; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_loc; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::IndexAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_call_operator_loc(repository); end
  def save_closing_loc(repository); end
  def save_opening_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    def type; end
  end
end

class Prism::IndexOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, binary_operator, binary_operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def operator; end
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_binary_operator_loc(repository); end
  def save_call_operator_loc(repository); end
  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    def type; end
  end
end

class Prism::IndexOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_call_operator_loc(repository); end
  def save_closing_loc(repository); end
  def save_opening_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    def type; end
  end
end

class Prism::IndexTargetNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode)
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, opening_loc, arguments, closing_loc, block); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode)
    ).returns(Prism::IndexTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Prism::Node) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    def type; end
  end
end

class Prism::InlineComment < ::Prism::Comment
  sig { returns(String) }
  def inspect; end

  sig { override.returns(T::Boolean) }
  def trailing?; end
end

class Prism::InspectVisitor < ::Prism::Visitor
  sig { params(indent: String).void }
  def initialize(indent = T.unsafe(nil)); end

  def commands; end

  sig { returns(String) }
  def compose; end

  def indent; end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end

  private

  def inspect_location(location); end
  def inspect_node(name, node); end

  class << self
    sig { params(node: Prism::Node).returns(String) }
    def compose(node); end
  end
end

class Prism::InspectVisitor::Replace
  def initialize(value); end

  def value; end
end

class Prism::InstanceVariableAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::InstanceVariableOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::InstanceVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  def operator; end
  def operator_loc; end
  def save_binary_operator_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::InstanceVariableOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::InstanceVariableReadNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::InstanceVariableTargetNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::InstanceVariableWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::InstanceVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

# Flags for integer nodes that correspond to the base of the integer.
module Prism::IntegerBaseFlags; end

Prism::IntegerBaseFlags::BINARY = T.let(T.unsafe(nil), Integer)
Prism::IntegerBaseFlags::DECIMAL = T.let(T.unsafe(nil), Integer)
Prism::IntegerBaseFlags::HEXADECIMAL = T.let(T.unsafe(nil), Integer)
Prism::IntegerBaseFlags::OCTAL = T.let(T.unsafe(nil), Integer)

class Prism::IntegerNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def binary?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Integer
    ).returns(Prism::IntegerNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def decimal?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def hexadecimal?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def octal?; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Integer) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::InterpolatedMatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedMatchLastLineNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def multi_line?; end

  def newline_flag!(lines); end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    def type; end
  end
end

class Prism::InterpolatedRegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedRegularExpressionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def multi_line?; end

  def newline_flag!(lines); end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    def type; end
  end
end

class Prism::InterpolatedStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode)],
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedStringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def frozen?; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def mutable?; end

  def newline_flag!(lines); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig do
    returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode)])
  end
  def parts; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
module Prism::InterpolatedStringNodeFlags; end

Prism::InterpolatedStringNodeFlags::FROZEN = T.let(T.unsafe(nil), Integer)
Prism::InterpolatedStringNodeFlags::MUTABLE = T.let(T.unsafe(nil), Integer)

class Prism::InterpolatedSymbolNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedSymbolNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  def newline_flag!(lines); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::InterpolatedXStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedXStringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  sig { override.returns(String) }
  def inspect; end

  def newline_flag!(lines); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ItLocalVariableReadNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ItLocalVariableReadNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ItParametersNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ItParametersNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::KeywordHashNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]
    ).void
  end
  def initialize(source, node_id, location, flags, elements); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]
    ).returns(Prism::KeywordHashNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def symbol_keys?; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for keyword hash nodes.
module Prism::KeywordHashNodeFlags; end

Prism::KeywordHashNodeFlags::SYMBOL_KEYS = T.let(T.unsafe(nil), Integer)

class Prism::KeywordRestParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::KeywordRestParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::LambdaNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))
    ).void
  end
  def initialize(source, node_id, location, flags, locals, operator_loc, opening_loc, closing_loc, parameters, body); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))
    ).returns(Prism::LambdaNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode))) }
  def parameters; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::LexCompat
  def initialize(source, **options); end

  def options; end
  def result; end
  def source; end
end

class Prism::LexCompat::EndContentToken < ::Prism::LexCompat::Token
  def ==(other); end
end

module Prism::LexCompat::Heredoc
  class << self
    def build(opening); end
  end
end

class Prism::LexCompat::Heredoc::DashHeredoc
  def initialize(split); end

  def <<(token); end
  def split; end
  def to_a; end
  def tokens; end
end

class Prism::LexCompat::Heredoc::DedentingHeredoc
  def initialize; end

  def <<(token); end
  def dedent; end
  def dedent_next; end
  def embexpr_balance; end
  def to_a; end
  def tokens; end
end

Prism::LexCompat::Heredoc::DedentingHeredoc::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

class Prism::LexCompat::Heredoc::PlainHeredoc
  def initialize; end

  def <<(token); end
  def to_a; end
  def tokens; end
end

class Prism::LexCompat::IdentToken < ::Prism::LexCompat::Token
  def ==(other); end
end

class Prism::LexCompat::IgnoreStateToken < ::Prism::LexCompat::Token
  def ==(other); end
end

class Prism::LexCompat::IgnoredNewlineToken < ::Prism::LexCompat::Token
  def ==(other); end
end

class Prism::LexCompat::ParamToken < ::Prism::LexCompat::Token
  def ==(other); end
end

Prism::LexCompat::RIPPER = T.let(T.unsafe(nil), Hash)

class Prism::LexCompat::Result < ::Prism::Result
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  def deconstruct_keys(keys); end
  def value; end
end

class Prism::LexCompat::Token < ::SimpleDelegator
  def event; end
  def location; end
  def state; end
  def value; end
end

class Prism::LexResult < ::Prism::Result
  sig do
    params(
      value: T::Array[T.untyped],
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Array[T.untyped]) }
  def value; end
end

class Prism::LexRipper
  def initialize(source); end

  def result; end
  def source; end

  private

  def lex(source); end
end

class Prism::LocalVariableAndWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name_loc, operator_loc, value, name, depth); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::LocalVariableOperatorWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      binary_operator: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name_loc, binary_operator_loc, value, name, binary_operator, depth); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Symbol) }
  def binary_operator; end

  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      binary_operator: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), binary_operator: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  def operator; end
  def operator_loc; end
  def save_binary_operator_loc(repository); end
  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::LocalVariableOrWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name_loc, operator_loc, value, name, depth); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::LocalVariableReadNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name, depth); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::LocalVariableTargetNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name, depth); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::LocalVariableWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, depth, name_loc, value, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::LocalVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::Location
  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).void }
  def initialize(source, start_offset, length); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { params(string: String).returns(Prism::Location) }
  def adjoin(string); end

  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_end_code_units_column(cache); end

  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_end_code_units_offset(cache); end

  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_start_code_units_column(cache); end

  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_start_code_units_offset(cache); end

  sig { returns(Prism::Location) }
  def chop; end

  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).returns(Prism::Location) }
  def copy(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def end_character_column; end

  sig { returns(Integer) }
  def end_character_offset; end

  sig { params(encoding: Encoding).returns(Integer) }
  def end_code_units_column(encoding = T.unsafe(nil)); end

  sig { params(encoding: Encoding).returns(Integer) }
  def end_code_units_offset(encoding = T.unsafe(nil)); end

  sig { returns(Integer) }
  def end_column; end

  sig { returns(Integer) }
  def end_line; end

  sig { returns(Integer) }
  def end_offset; end

  sig { returns(String) }
  def inspect; end

  sig { params(other: Prism::Location).returns(Prism::Location) }
  def join(other); end

  sig { params(comment: Prism::Comment).void }
  def leading_comment(comment); end

  sig { returns(T::Array[Prism::Comment]) }
  def leading_comments; end

  sig { returns(Integer) }
  def length; end

  sig { params(q: T.untyped).void }
  def pretty_print(q); end

  sig { returns(String) }
  def slice; end

  def slice_lines; end

  sig { returns(T::Array[String]) }
  def source_lines; end

  sig { returns(Integer) }
  def start_character_column; end

  sig { returns(Integer) }
  def start_character_offset; end

  sig { params(encoding: Encoding).returns(Integer) }
  def start_code_units_column(encoding = T.unsafe(nil)); end

  sig { params(encoding: Encoding).returns(Integer) }
  def start_code_units_offset(encoding = T.unsafe(nil)); end

  sig { returns(Integer) }
  def start_column; end

  sig { returns(Integer) }
  def start_line; end

  sig { returns(String) }
  def start_line_slice; end

  sig { returns(Integer) }
  def start_offset; end

  sig { params(comment: Prism::Comment).void }
  def trailing_comment(comment); end

  sig { returns(T::Array[Prism::Comment]) }
  def trailing_comments; end

  protected

  sig { returns(Prism::Source) }
  def source; end
end

# Flags for while and until loop nodes.
module Prism::LoopFlags; end

Prism::LoopFlags::BEGIN_MODIFIER = T.let(T.unsafe(nil), Integer)

class Prism::MagicComment
  sig { params(key_loc: Prism::Location, value_loc: Prism::Location).void }
  def initialize(key_loc, value_loc); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def inspect; end

  sig { returns(String) }
  def key; end

  sig { returns(Prism::Location) }
  def key_loc; end

  sig { returns(String) }
  def value; end

  sig { returns(Prism::Location) }
  def value_loc; end
end

class Prism::MatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::MatchLastLineNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def multi_line?; end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  def save_closing_loc(repository); end
  def save_content_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(String) }
  def unescaped; end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    def type; end
  end
end

class Prism::MatchPredicateNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, pattern, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchPredicateNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def pattern; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::MatchRequiredNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, pattern, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchRequiredNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def pattern; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::MatchWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      call: Prism::CallNode,
      targets: T::Array[Prism::LocalVariableTargetNode]
    ).void
  end
  def initialize(source, node_id, location, flags, call, targets); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(Prism::CallNode) }
  def call; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      call: Prism::CallNode,
      targets: T::Array[Prism::LocalVariableTargetNode]
    ).returns(Prism::MatchWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), call: T.unsafe(nil), targets: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Prism::LocalVariableTargetNode]) }
  def targets; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::MissingNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::MissingNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ModuleNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, locals, module_keyword_loc, constant_path, body, end_keyword_loc, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode)) }
  def constant_path; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ModuleNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def module_keyword; end

  sig { returns(Prism::Location) }
  def module_keyword_loc; end

  sig { returns(Symbol) }
  def name; end

  def save_end_keyword_loc(repository); end
  def save_module_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::MultiTargetNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, lefts, rest, rights, lparen_loc, rparen_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::MultiTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def lefts; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode))) }
  def rest; end

  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def rights; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  def save_lparen_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::MultiWriteNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::MultiWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def lefts; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode))) }
  def rest; end

  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def rights; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  def save_lparen_loc(repository); end
  def save_operator_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::MutationCompiler < ::Prism::Compiler
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end
end

class Prism::NextNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, arguments, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::NextNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::NilNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::NilNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::NoKeywordsParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, operator_loc, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location
    ).returns(Prism::NoKeywordsParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_keyword_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::Node
  abstract!

  sig { abstract.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { params(block: T.proc.params(node: Prism::Node).returns(T::Boolean)).returns(T.nilable(Prism::Node)) }
  def breadth_first_search(&block); end

  def cached_end_code_units_column(cache); end
  def cached_end_code_units_offset(cache); end
  def cached_start_code_units_column(cache); end
  def cached_start_code_units_offset(cache); end

  sig { abstract.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { abstract.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  def comments; end

  sig { abstract.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { abstract.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  def deprecated(*replacements); end
  def end_character_column; end
  def end_character_offset; end
  def end_column; end
  def end_line; end

  sig { returns(Integer) }
  def end_offset; end

  sig { abstract.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { abstract.returns(String) }
  def inspect; end

  def leading_comments; end

  sig { returns(Prism::Location) }
  def location; end

  sig { returns(T::Boolean) }
  def newline?; end

  def newline_flag!(lines); end
  def newline_flag?; end

  sig { returns(Integer) }
  def node_id; end

  sig { params(q: T.untyped).void }
  def pretty_print(q); end

  def save(repository); end
  def save_location(repository); end

  sig { returns(T::Array[String]) }
  def script_lines; end

  sig { returns(String) }
  def slice; end

  sig { returns(String) }
  def slice_lines; end

  sig { returns(T::Array[String]) }
  def source_lines; end

  def start_character_column; end
  def start_character_offset; end
  def start_column; end
  def start_line; end

  sig { returns(Integer) }
  def start_offset; end

  sig { returns(T::Boolean) }
  def static_literal?; end

  sig { returns(String) }
  def to_dot; end

  def trailing_comments; end

  sig { params(line: Integer, column: Integer).returns(T::Array[Prism::Node]) }
  def tunnel(line, column); end

  sig { abstract.returns(Symbol) }
  def type; end

  protected

  sig { returns(Integer) }
  def flags; end

  private

  sig { returns(Prism::Source) }
  def source; end

  class << self
    def fields; end
    def type; end
  end
end

# The flags that are common to all nodes.
module Prism::NodeFlags; end

Prism::NodeFlags::NEWLINE = T.let(T.unsafe(nil), Integer)
Prism::NodeFlags::STATIC_LITERAL = T.let(T.unsafe(nil), Integer)

class Prism::NumberedParametersNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      maximum: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, maximum); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      maximum: Integer
    ).returns(Prism::NumberedParametersNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), maximum: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Integer) }
  def maximum; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::NumberedReferenceReadNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      number: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, number); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      number: Integer
    ).returns(Prism::NumberedReferenceReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), number: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Integer) }
  def number; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::OptionalKeywordParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalKeywordParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::OptionalParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Prism::Node) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::OrNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::OrNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def right; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

module Prism::Pack
  class << self
    def parse(_arg0, _arg1, _arg2); end
  end
end

Prism::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)
Prism::Pack::BACK = T.let(T.unsafe(nil), Symbol)
Prism::Pack::BER = T.let(T.unsafe(nil), Symbol)
Prism::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)
Prism::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

class Prism::Pack::Directive
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  def describe; end
  def endian; end
  def length; end
  def length_type; end
  def signed; end
  def size; end
  def source; end
  def type; end
  def variant; end
  def version; end
end

Prism::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
Prism::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
Prism::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
Prism::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)
Prism::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

class Prism::Pack::Format
  def initialize(directives, encoding); end

  def describe; end
  def directives; end
  def encoding; end
end

Prism::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)
Prism::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)
Prism::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)
Prism::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)
Prism::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)
Prism::Pack::MOVE = T.let(T.unsafe(nil), Symbol)
Prism::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)
Prism::Pack::NULL = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)
Prism::Pack::SPACE = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)
Prism::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)
Prism::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Flags for parameter nodes.
module Prism::ParameterFlags; end

Prism::ParameterFlags::REPEATED_PARAMETER = T.let(T.unsafe(nil), Integer)

class Prism::ParametersNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      requireds: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)],
      optionals: T::Array[Prism::OptionalParameterNode],
      rest: T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode)),
      posts: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)],
      keywords: T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)],
      keyword_rest: T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)),
      block: T.nilable(Prism::BlockParameterNode)
    ).void
  end
  def initialize(source, node_id, location, flags, requireds, optionals, rest, posts, keywords, keyword_rest, block); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::BlockParameterNode)) }
  def block; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      requireds: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)],
      optionals: T::Array[Prism::OptionalParameterNode],
      rest: T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode)),
      posts: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)],
      keywords: T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)],
      keyword_rest: T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)),
      block: T.nilable(Prism::BlockParameterNode)
    ).returns(Prism::ParametersNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig do
    returns(T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)))
  end
  def keyword_rest; end

  sig { returns(T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)]) }
  def keywords; end

  sig { returns(T::Array[Prism::OptionalParameterNode]) }
  def optionals; end

  sig do
    returns(T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)])
  end
  def posts; end

  sig { returns(T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)]) }
  def requireds; end

  sig { returns(T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode))) }
  def rest; end

  sig { returns(T::Array[T.any([Symbol, Symbol], [Symbol])]) }
  def signature; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ParenthesesNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, body, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::ParenthesesNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def multiple_statements?; end

  def newline_flag!(lines); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for parentheses nodes.
module Prism::ParenthesesNodeFlags; end

Prism::ParenthesesNodeFlags::MULTIPLE_STATEMENTS = T.let(T.unsafe(nil), Integer)

class Prism::ParseError
  sig { params(type: Symbol, message: String, location: Prism::Location, level: Symbol).void }
  def initialize(type, message, location, level); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def level; end

  sig { returns(Prism::Location) }
  def location; end

  sig { returns(String) }
  def message; end

  sig { returns(Symbol) }
  def type; end
end

class Prism::ParseLexResult < ::Prism::Result
  sig do
    params(
      value: [Prism::ProgramNode, T::Array[T.untyped]],
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns([Prism::ProgramNode, T::Array[T.untyped]]) }
  def value; end
end

class Prism::ParseResult < ::Prism::Result
  sig do
    params(
      value: Prism::ProgramNode,
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  def attach_comments!; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def errors_format; end
  def mark_newlines!; end

  sig { returns(Prism::ProgramNode) }
  def value; end
end

class Prism::ParseResult::Comments
  def initialize(parse_result); end

  def attach!; end
  def parse_result; end

  private

  def nearest_targets(node, comment); end
end

class Prism::ParseResult::Comments::LocationTarget
  def initialize(location); end

  def encloses?(comment); end
  def end_offset; end
  def leading_comment(comment); end
  def location; end
  def start_offset; end
  def trailing_comment(comment); end
end

class Prism::ParseResult::Comments::NodeTarget
  def initialize(node); end

  def encloses?(comment); end
  def end_offset; end
  def leading_comment(comment); end
  def node; end
  def start_offset; end
  def trailing_comment(comment); end
end

class Prism::ParseResult::Errors
  def initialize(parse_result); end

  def format; end
  def parse_result; end
end

class Prism::ParseResult::Newlines < ::Prism::Visitor
  def initialize(lines); end

  def visit_block_node(node); end
  def visit_if_node(node); end
  def visit_lambda_node(node); end
  def visit_statements_node(node); end
  def visit_unless_node(node); end
end

class Prism::ParseWarning
  sig { params(type: Symbol, message: String, location: Prism::Location, level: Symbol).void }
  def initialize(type, message, location, level); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def level; end

  sig { returns(Prism::Location) }
  def location; end

  sig { returns(String) }
  def message; end

  sig { returns(Symbol) }
  def type; end
end

class Prism::Pattern
  def initialize(query); end

  def compile; end
  def query; end
  def scan(root); end

  private

  def combine_and(left, right); end
  def combine_or(left, right); end
  def compile_alternation_pattern_node(node); end
  def compile_array_pattern_node(node); end
  def compile_constant_name(node, name); end
  def compile_constant_path_node(node); end
  def compile_constant_read_node(node); end
  def compile_error(node); end
  def compile_hash_pattern_node(node); end
  def compile_nil_node(node); end
  def compile_node(node); end
  def compile_regular_expression_node(node); end
  def compile_string_node(node); end
  def compile_symbol_node(node); end
end

class Prism::Pattern::CompilationError < ::StandardError
  def initialize(repr); end
end

class Prism::PinnedExpressionNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, expression, operator_loc, lparen_loc, rparen_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location
    ).returns(Prism::PinnedExpressionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Prism::Node) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def lparen; end

  sig { returns(Prism::Location) }
  def lparen_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(String) }
  def rparen; end

  sig { returns(Prism::Location) }
  def rparen_loc; end

  def save_lparen_loc(repository); end
  def save_operator_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::PinnedVariableNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      variable: T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, variable, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      variable: T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode),
      operator_loc: Prism::Location
    ).returns(Prism::PinnedVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), variable: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig do
    returns(T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode))
  end
  def variable; end

  class << self
    def type; end
  end
end

class Prism::PostExecutionNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, statements, keyword_loc, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PostExecutionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_keyword_loc(repository); end
  def save_opening_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::PreExecutionNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, statements, keyword_loc, opening_loc, closing_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PreExecutionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_keyword_loc(repository); end
  def save_opening_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ProgramNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode
    ).void
  end
  def initialize(source, node_id, location, flags, locals, statements); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode
    ).returns(Prism::ProgramNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(Prism::StatementsNode) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for range and flip-flop nodes.
module Prism::RangeFlags; end

Prism::RangeFlags::EXCLUDE_END = T.let(T.unsafe(nil), Integer)

class Prism::RangeNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::RangeNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def exclude_end?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::RationalNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numerator: Integer,
      denominator: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, numerator, denominator); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def binary?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numerator: Integer,
      denominator: Integer
    ).returns(Prism::RationalNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numerator: T.unsafe(nil), denominator: T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def decimal?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def denominator; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def hexadecimal?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Integer) }
  def numerator; end

  def numeric; end

  sig { returns(T::Boolean) }
  def octal?; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(Rational) }
  def value; end

  class << self
    def type; end
  end
end

class Prism::RedoNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::RedoNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

module Prism::Reflection
  class << self
    sig { params(node: T.class_of(Prism::Node)).returns(T::Array[Prism::Reflection::Field]) }
    def fields_for(node); end
  end
end

class Prism::Reflection::ConstantField < ::Prism::Reflection::Field; end
class Prism::Reflection::ConstantListField < ::Prism::Reflection::Field; end

class Prism::Reflection::Field
  sig { params(name: Symbol).void }
  def initialize(name); end

  sig { returns(Symbol) }
  def name; end
end

class Prism::Reflection::FlagsField < ::Prism::Reflection::Field
  sig { params(name: Symbol, flags: T::Array[Symbol]).void }
  def initialize(name, flags); end

  sig { returns(T::Array[Symbol]) }
  def flags; end
end

class Prism::Reflection::FloatField < ::Prism::Reflection::Field; end
class Prism::Reflection::IntegerField < ::Prism::Reflection::Field; end
class Prism::Reflection::LocationField < ::Prism::Reflection::Field; end
class Prism::Reflection::NodeField < ::Prism::Reflection::Field; end
class Prism::Reflection::NodeListField < ::Prism::Reflection::Field; end
class Prism::Reflection::OptionalConstantField < ::Prism::Reflection::Field; end
class Prism::Reflection::OptionalLocationField < ::Prism::Reflection::Field; end
class Prism::Reflection::OptionalNodeField < ::Prism::Reflection::Field; end
class Prism::Reflection::StringField < ::Prism::Reflection::Field; end

# Flags for regular expression and match last line nodes.
module Prism::RegularExpressionFlags; end

Prism::RegularExpressionFlags::ASCII_8BIT = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::EUC_JP = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::EXTENDED = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::IGNORE_CASE = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::MULTI_LINE = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::ONCE = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::UTF_8 = T.let(T.unsafe(nil), Integer)
Prism::RegularExpressionFlags::WINDOWS_31J = T.let(T.unsafe(nil), Integer)

class Prism::RegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::RegularExpressionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def multi_line?; end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  def save_closing_loc(repository); end
  def save_content_loc(repository); end
  def save_opening_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(String) }
  def unescaped; end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    def type; end
  end
end

module Prism::RegularExpressionOptions
  def options; end
end

module Prism::Relocation
  class << self
    def filepath(value); end
    def string(value); end
  end
end

class Prism::Relocation::CharacterColumnsField
  def fields(value); end
end

class Prism::Relocation::CharacterOffsetsField
  def fields(value); end
end

class Prism::Relocation::CodeUnitColumnsField
  def initialize(repository, encoding); end

  def encoding; end
  def fields(value); end
  def repository; end

  private

  def cache; end
end

class Prism::Relocation::CodeUnitOffsetsField
  def initialize(repository, encoding); end

  def encoding; end
  def fields(value); end
  def repository; end

  private

  def cache; end
end

class Prism::Relocation::ColumnsField
  def fields(value); end
end

class Prism::Relocation::CommentsField
  private

  def comments(values); end
end

class Prism::Relocation::CommentsField::Comment
  def initialize(slice); end

  def slice; end
end

class Prism::Relocation::Entry
  def initialize(repository); end

  def comments; end
  def end_character_column; end
  def end_character_offset; end
  def end_code_units_column; end
  def end_code_units_offset; end
  def end_column; end
  def end_line; end
  def end_offset; end
  def filepath; end
  def leading_comments; end
  def reify!(values); end
  def start_character_column; end
  def start_character_offset; end
  def start_code_units_column; end
  def start_code_units_offset; end
  def start_column; end
  def start_line; end
  def start_offset; end
  def trailing_comments; end

  private

  def fetch_value(name); end
  def values; end
end

class Prism::Relocation::Entry::MissingValueError < ::StandardError; end

class Prism::Relocation::FilepathField
  def initialize(value); end

  def fields(_value); end
  def value; end
end

class Prism::Relocation::LeadingCommentsField < ::Prism::Relocation::CommentsField
  def fields(value); end
end

class Prism::Relocation::LinesField
  def fields(value); end
end

class Prism::Relocation::OffsetsField
  def fields(value); end
end

class Prism::Relocation::Repository
  def initialize(source); end

  def character_columns; end
  def character_offsets; end
  def code_unit_columns(encoding); end
  def code_unit_offsets(encoding); end
  def code_units_cache(encoding); end
  def columns; end
  def comments; end
  def enter(node_id, field_name); end
  def entries; end
  def fields; end
  def filepath; end
  def leading_comments; end
  def lines; end
  def offsets; end
  def reify!; end
  def source; end
  def trailing_comments; end

  private

  def field(name, value); end
end

class Prism::Relocation::Repository::ConfigurationError < ::StandardError; end

class Prism::Relocation::Source
  def initialize(value); end

  def code_units_cache(encoding); end
  def result; end
  def value; end
end

class Prism::Relocation::SourceFilepath < ::Prism::Relocation::Source
  def result; end
end

class Prism::Relocation::SourceString < ::Prism::Relocation::Source
  def result; end
end

class Prism::Relocation::TrailingCommentsField < ::Prism::Relocation::CommentsField
  def fields(value); end
end

class Prism::RequiredKeywordParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location
    ).returns(Prism::RequiredKeywordParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  def save_name_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::RequiredParameterNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::RequiredParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::RescueModifierNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, expression, keyword_loc, rescue_expression); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node
    ).returns(Prism::RescueModifierNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Prism::Node) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def newline_flag!(lines); end

  sig { returns(Prism::Node) }
  def rescue_expression; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::RescueNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)),
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(Prism::RescueNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, exceptions, operator_loc, reference, then_keyword_loc, statements, subsequent); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  def consequent; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)),
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(Prism::RescueNode)
    ).returns(Prism::RescueNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def exceptions; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  sig do
    returns(T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)))
  end
  def reference; end

  def save_keyword_loc(repository); end
  def save_operator_loc(repository); end
  def save_then_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(Prism::RescueNode)) }
  def subsequent; end

  sig { returns(T.nilable(String)) }
  def then_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::RestParameterNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::RestParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  def save_name_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::Result
  sig do
    params(
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(comments, magic_comments, data_loc, errors, warnings, source); end

  sig do
    params(
      encoding: Encoding
    ).returns(T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer)))
  end
  def code_units_cache(encoding); end

  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  sig { returns(T.nilable(Prism::Location)) }
  def data_loc; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(Encoding) }
  def encoding; end

  sig { returns(T::Array[Prism::ParseError]) }
  def errors; end

  sig { returns(T::Boolean) }
  def failure?; end

  sig { returns(T::Array[Prism::MagicComment]) }
  def magic_comments; end

  sig { returns(Prism::Source) }
  def source; end

  sig { returns(T::Boolean) }
  def success?; end

  sig { returns(T::Array[Prism::ParseWarning]) }
  def warnings; end
end

class Prism::RetryNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::RetryNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::ReturnNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, arguments); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode)
    ).returns(Prism::ReturnNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::Scope
  sig { params(locals: T::Array[Symbol], forwarding: T::Array[Symbol]).void }
  def initialize(locals, forwarding); end

  sig { returns(T::Array[Symbol]) }
  def forwarding; end

  sig { returns(T::Array[Symbol]) }
  def locals; end
end

class Prism::SelfNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::SelfNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

module Prism::Serialize
  class << self
    def load_lex(input, serialized, freeze); end
    def load_parse(input, serialized, freeze); end
    def load_parse_comments(input, serialized, freeze); end
    def load_parse_lex(input, serialized, freeze); end
  end
end

class Prism::Serialize::ConstantPool
  def initialize(input, serialized, base, size); end

  def get(index, encoding); end
  def size; end
end

Prism::Serialize::FastStringIO = StringIO

class Prism::Serialize::Loader
  def initialize(source, serialized); end

  def eof?; end
  def input; end
  def io; end
  def load_comments(freeze); end
  def load_constant(constant_pool, encoding); end
  def load_constant_pool(constant_pool); end
  def load_double; end
  def load_embedded_string(encoding); end
  def load_encoding; end
  def load_error_level; end
  def load_errors(encoding, freeze); end
  def load_header; end
  def load_integer; end
  def load_line_offsets(freeze); end
  def load_location(freeze); end
  def load_location_object(freeze); end
  def load_magic_comments(freeze); end
  def load_node(constant_pool, encoding, freeze); end
  def load_optional_constant(constant_pool, encoding); end
  def load_optional_location(freeze); end
  def load_optional_location_object(freeze); end
  def load_optional_node(constant_pool, encoding, freeze); end
  def load_string(encoding); end
  def load_tokens; end
  def load_uint32; end
  def load_varsint; end
  def load_varuint; end
  def load_warning_level; end
  def load_warnings(encoding, freeze); end
  def source; end
end

Prism::Serialize::Loader::DIAGNOSTIC_TYPES = T.let(T.unsafe(nil), Array)
Prism::Serialize::MAJOR_VERSION = T.let(T.unsafe(nil), Integer)
Prism::Serialize::MINOR_VERSION = T.let(T.unsafe(nil), Integer)
Prism::Serialize::PATCH_VERSION = T.let(T.unsafe(nil), Integer)
Prism::Serialize::TOKEN_TYPES = T.let(T.unsafe(nil), Array)

class Prism::ShareableConstantNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      write: T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode)
    ).void
  end
  def initialize(source, node_id, location, flags, write); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      write: T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode)
    ).returns(Prism::ShareableConstantNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), write: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def experimental_copy?; end

  sig { returns(T::Boolean) }
  def experimental_everything?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def literal?; end

  sig { override.returns(Symbol) }
  def type; end

  sig do
    returns(T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode))
  end
  def write; end

  class << self
    def type; end
  end
end

# Flags for shareable constant nodes.
module Prism::ShareableConstantNodeFlags; end

Prism::ShareableConstantNodeFlags::EXPERIMENTAL_COPY = T.let(T.unsafe(nil), Integer)
Prism::ShareableConstantNodeFlags::EXPERIMENTAL_EVERYTHING = T.let(T.unsafe(nil), Integer)
Prism::ShareableConstantNodeFlags::LITERAL = T.let(T.unsafe(nil), Integer)

class Prism::SingletonClassNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def class_keyword; end

  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location
    ).returns(Prism::SingletonClassNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { returns(Prism::Node) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_class_keyword_loc(repository); end
  def save_end_keyword_loc(repository); end
  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::Source
  sig { params(source: String, start_line: Integer, offsets: T::Array[Integer]).void }
  def initialize(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end

  sig { params(byte_offset: Integer).returns(Integer) }
  def character_column(byte_offset); end

  sig { params(byte_offset: Integer).returns(Integer) }
  def character_offset(byte_offset); end

  sig do
    params(
      encoding: Encoding
    ).returns(T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer)))
  end
  def code_units_cache(encoding); end

  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_column(byte_offset, encoding); end

  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_offset(byte_offset, encoding); end

  sig { params(byte_offset: Integer).returns(Integer) }
  def column(byte_offset); end

  def deep_freeze; end

  sig { returns(Encoding) }
  def encoding; end

  sig { params(byte_offset: Integer).returns(Integer) }
  def line(byte_offset); end

  def line_end(byte_offset); end

  sig { params(byte_offset: Integer).returns(Integer) }
  def line_start(byte_offset); end

  sig { returns(T::Array[String]) }
  def lines; end

  sig { returns(T::Array[Integer]) }
  def offsets; end

  sig { params(offsets: T::Array[Integer]).void }
  def replace_offsets(offsets); end

  sig { params(start_line: Integer).void }
  def replace_start_line(start_line); end

  sig { params(byte_offset: Integer, length: Integer).returns(String) }
  def slice(byte_offset, length); end

  sig { returns(String) }
  def source; end

  sig { returns(Integer) }
  def start_line; end

  private

  def find_line(byte_offset); end

  class << self
    def for(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end
  end
end

class Prism::SourceEncodingNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::SourceEncodingNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::SourceFileNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      filepath: String
    ).void
  end
  def initialize(source, node_id, location, flags, filepath); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      filepath: String
    ).returns(Prism::SourceFileNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), filepath: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(String) }
  def filepath; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def frozen?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def mutable?; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::SourceLineNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::SourceLineNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::SplatNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node)
    ).void
  end
  def initialize(source, node_id, location, flags, operator_loc, expression); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node)
    ).returns(Prism::SplatNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  def save_operator_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::StatementsNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T::Array[Prism::Node]
    ).void
  end
  def initialize(source, node_id, location, flags, body); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Array[Prism::Node]) }
  def body; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T::Array[Prism::Node]
    ).returns(Prism::StatementsNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for string nodes.
module Prism::StringFlags; end

Prism::StringFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::StringFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::StringFlags::FROZEN = T.let(T.unsafe(nil), Integer)
Prism::StringFlags::MUTABLE = T.let(T.unsafe(nil), Integer)

class Prism::StringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::StringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def frozen?; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T::Boolean) }
  def mutable?; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_content_loc(repository); end
  def save_opening_loc(repository); end

  sig { returns(Prism::InterpolatedStringNode) }
  def to_interpolated; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(String) }
  def unescaped; end

  class << self
    def type; end
  end
end

class Prism::StringQuery
  def initialize(string); end

  def constant?; end
  def local?; end
  def method_name?; end
  def string; end

  class << self
    def constant?(_arg0); end
    def local?(_arg0); end
    def method_name?(_arg0); end
  end
end

class Prism::SuperNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, lparen_loc, arguments, rparen_loc, block); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))) }
  def block; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::SuperNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  def save_keyword_loc(repository); end
  def save_lparen_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

# Flags for symbol nodes.
module Prism::SymbolFlags; end

Prism::SymbolFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::SymbolFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)
Prism::SymbolFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

class Prism::SymbolNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, value_loc, closing_loc, unescaped); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::SymbolNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_opening_loc(repository); end
  def save_value_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(String) }
  def unescaped; end

  sig { returns(T.nilable(String)) }
  def value; end

  sig { returns(T.nilable(Prism::Location)) }
  def value_loc; end

  class << self
    def type; end
  end
end

class Prism::Token
  sig { params(source: Prism::Source, type: Symbol, value: String, location: T.any(Integer, Prism::Location)).void }
  def initialize(source, type, value, location); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  def deep_freeze; end
  def inspect; end

  sig { returns(Prism::Location) }
  def location; end

  sig { params(q: T.untyped).void }
  def pretty_print(q); end

  sig { returns(Symbol) }
  def type; end

  sig { returns(String) }
  def value; end

  private

  sig { returns(Prism::Source) }
  def source; end
end

module Prism::Translation; end

class Prism::Translation::Parser < ::Parser::Base
  def initialize(builder = T.unsafe(nil), parser: T.unsafe(nil)); end

  def default_encoding; end
  def parse(source_buffer); end
  def parse_with_comments(source_buffer); end
  def tokenize(source_buffer, recover = T.unsafe(nil)); end
  def try_declare_numparam(node); end

  sig { overridable.returns(Integer) }
  def version; end

  def yyerror; end

  private

  def build_ast(program, offset_cache); end
  def build_comments(comments, offset_cache); end
  def build_offset_cache(source); end
  def build_range(location, offset_cache); end
  def build_tokens(tokens, offset_cache); end
  def convert_for_prism(version); end
  def error_diagnostic(error, offset_cache); end
  def prism_options; end
  def unwrap(result, offset_cache); end
  def valid_error?(error); end
  def valid_warning?(warning); end
  def warning_diagnostic(warning, offset_cache); end
end

class Prism::Translation::Parser33 < ::Prism::Translation::Parser
  sig { override.returns(Integer) }
  def version; end
end

class Prism::Translation::Parser34 < ::Prism::Translation::Parser
  sig { override.returns(Integer) }
  def version; end
end

class Prism::Translation::Parser35 < ::Prism::Translation::Parser
  sig { override.returns(Integer) }
  def version; end
end

class Prism::Translation::Parser::Builder < ::Parser::Builders::Default
  def block(method_call, begin_t, args, body, end_t); end
  def itarg; end
end

class Prism::Translation::Parser::Compiler < ::Prism::Compiler
  def initialize(parser, offset_cache, forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  def builder; end
  def forwarding; end
  def in_destructure; end
  def in_pattern; end
  def offset_cache; end
  def parser; end
  def source_buffer; end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end

  private

  def copy_compiler(forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end
  def find_forwarding(node); end
  def multi_target_elements(node); end
  def numeric_negate(message_loc, receiver); end
  def procarg0?(parameters); end
  def srange(location); end
  def srange_find(start_offset, end_offset, character); end
  def srange_offsets(start_offset, end_offset); end
  def string_nodes_from_interpolation(node, opening); end
  def string_nodes_from_line_continuations(unescaped, escaped, start_offset, opening); end
  def token(location); end
  def visit_block(call, block); end
  def visit_heredoc(node); end
  def visit_numeric(node, value); end
  def within_pattern; end
end

class Prism::Translation::Parser::Compiler::CompilationError < ::StandardError; end
Prism::Translation::Parser::Compiler::Range = Parser::Source::Range
Prism::Translation::Parser::Diagnostic = Parser::Diagnostic

class Prism::Translation::Parser::Lexer
  def initialize(source_buffer, lexed, offset_cache); end

  def lexed; end
  def offset_cache; end
  def source_buffer; end
  def to_a; end

  private

  def calculate_heredoc_whitespace(heredoc_token_index); end
  def escape_build(value, control, meta); end
  def escape_read(result, scanner, control, meta); end
  def interpolation?(quote); end
  def parse_complex(value); end
  def parse_float(value); end
  def parse_integer(value); end
  def parse_rational(value); end
  def percent_array?(quote); end
  def percent_array_leading_whitespace(string); end
  def percent_array_unescape(string); end
  def range(start_offset, end_offset); end
  def regexp?(quote); end
  def simplify_string?(value, quote); end
  def trim_heredoc_whitespace(string, heredoc); end
  def unescape_string(string, quote); end
end

Prism::Translation::Parser::Lexer::COMMENT_CONTINUATION_TYPES = T.let(T.unsafe(nil), Set)
Prism::Translation::Parser::Lexer::DELIMITER_SYMETRY = T.let(T.unsafe(nil), Hash)
Prism::Translation::Parser::Lexer::ESCAPES = T.let(T.unsafe(nil), Hash)
Prism::Translation::Parser::Lexer::EXPR_BEG = T.let(T.unsafe(nil), Integer)
Prism::Translation::Parser::Lexer::EXPR_LABEL = T.let(T.unsafe(nil), Integer)

class Prism::Translation::Parser::Lexer::HeredocData < ::Struct
  def common_whitespace; end
  def common_whitespace=(_); end
  def identifier; end
  def identifier=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Prism::Translation::Parser::Lexer::LAMBDA_TOKEN_TYPES = T.let(T.unsafe(nil), Set)
Prism::Translation::Parser::Lexer::LPAREN_CONVERSION_TOKEN_TYPES = T.let(T.unsafe(nil), Set)
Prism::Translation::Parser::Lexer::REGEXP_META_CHARACTERS = T.let(T.unsafe(nil), Array)
Prism::Translation::Parser::Lexer::Range = Parser::Source::Range
Prism::Translation::Parser::Lexer::TYPES = T.let(T.unsafe(nil), Hash)
Prism::Translation::Parser::Lexer::TYPES_ALWAYS_SKIP = T.let(T.unsafe(nil), Set)

class Prism::Translation::Parser::PrismDiagnostic < ::Parser::Diagnostic
  def initialize(message, level, reason, location); end

  def message; end
end

Prism::Translation::Parser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)
Prism::Translation::ParserCurrent = Prism::Translation::Parser34

class Prism::Translation::Ripper < ::Prism::Compiler
  def initialize(source, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

  def column; end

  sig { returns(T::Boolean) }
  def error?; end

  def filename; end
  def lineno; end

  sig { returns(T.untyped) }
  def parse; end

  def source; end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_it_parameters_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end

  private

  def _dispatch_0; end
  def _dispatch_1(_); end
  def _dispatch_2(_, _); end
  def _dispatch_3(_, _, _); end
  def _dispatch_4(_, _, _, _); end
  def _dispatch_5(_, _, _, _, _); end
  def _dispatch_7(_, _, _, _, _, _, _); end
  def bounds(location); end
  def command?(node); end
  def compile_error(msg); end
  def dedent_string(string, width); end
  def on_BEGIN(_); end
  def on_CHAR(_); end
  def on_END(_); end
  def on___end__(_); end
  def on_alias(_, _); end
  def on_alias_error(_, _); end
  def on_aref(_, _); end
  def on_aref_field(_, _); end
  def on_arg_ambiguous(_); end
  def on_arg_paren(_); end
  def on_args_add(_, _); end
  def on_args_add_block(_, _); end
  def on_args_add_star(_, _); end
  def on_args_forward; end
  def on_args_new; end
  def on_array(_); end
  def on_aryptn(_, _, _, _); end
  def on_assign(_, _); end
  def on_assign_error(_, _); end
  def on_assoc_new(_, _); end
  def on_assoc_splat(_); end
  def on_assoclist_from_args(_); end
  def on_backref(_); end
  def on_backtick(_); end
  def on_bare_assoc_hash(_); end
  def on_begin(_); end
  def on_binary(_, _, _); end
  def on_block_var(_, _); end
  def on_blockarg(_); end
  def on_bodystmt(_, _, _, _); end
  def on_brace_block(_, _); end
  def on_break(_); end
  def on_call(_, _, _); end
  def on_case(_, _); end
  def on_class(_, _, _); end
  def on_class_name_error(_, _); end
  def on_comma(_); end
  def on_command(_, _); end
  def on_command_call(_, _, _, _); end
  def on_comment(_); end
  def on_const(_); end
  def on_const_path_field(_, _); end
  def on_const_path_ref(_, _); end
  def on_const_ref(_); end
  def on_cvar(_); end
  def on_def(_, _, _); end
  def on_defined(_); end
  def on_defs(_, _, _, _, _); end
  def on_do_block(_, _); end
  def on_dot2(_, _); end
  def on_dot3(_, _); end
  def on_dyna_symbol(_); end
  def on_else(_); end
  def on_elsif(_, _, _); end
  def on_embdoc(_); end
  def on_embdoc_beg(_); end
  def on_embdoc_end(_); end
  def on_embexpr_beg(_); end
  def on_embexpr_end(_); end
  def on_embvar(_); end
  def on_ensure(_); end
  def on_excessed_comma; end
  def on_fcall(_); end
  def on_field(_, _, _); end
  def on_float(_); end
  def on_fndptn(_, _, _, _); end
  def on_for(_, _, _); end
  def on_gvar(_); end
  def on_hash(_); end
  def on_heredoc_beg(_); end
  def on_heredoc_dedent(_, _); end
  def on_heredoc_end(_); end
  def on_hshptn(_, _, _); end
  def on_ident(_); end
  def on_if(_, _, _); end
  def on_if_mod(_, _); end
  def on_ifop(_, _, _); end
  def on_ignored_nl(_); end
  def on_ignored_sp(_); end
  def on_imaginary(_); end
  def on_in(_, _, _); end
  def on_int(_); end
  def on_ivar(_); end
  def on_kw(_); end
  def on_kwrest_param(_); end
  def on_label(_); end
  def on_label_end(_); end
  def on_lambda(_, _); end
  def on_lbrace(_); end
  def on_lbracket(_); end
  def on_lparen(_); end
  def on_magic_comment(_, _); end
  def on_massign(_, _); end
  def on_method_add_arg(_, _); end
  def on_method_add_block(_, _); end
  def on_mlhs_add(_, _); end
  def on_mlhs_add_post(_, _); end
  def on_mlhs_add_star(_, _); end
  def on_mlhs_new; end
  def on_mlhs_paren(_); end
  def on_module(_, _); end
  def on_mrhs_add(_, _); end
  def on_mrhs_add_star(_, _); end
  def on_mrhs_new; end
  def on_mrhs_new_from_args(_); end
  def on_next(_); end
  def on_nl(_); end
  def on_nokw_param(_); end
  def on_op(_); end
  def on_opassign(_, _, _); end
  def on_operator_ambiguous(_, _); end
  def on_param_error(_, _); end
  def on_params(_, _, _, _, _, _, _); end
  def on_paren(_); end
  def on_parse_error(_); end
  def on_period(_); end
  def on_program(_); end
  def on_qsymbols_add(_, _); end
  def on_qsymbols_beg(_); end
  def on_qsymbols_new; end
  def on_qwords_add(_, _); end
  def on_qwords_beg(_); end
  def on_qwords_new; end
  def on_rational(_); end
  def on_rbrace(_); end
  def on_rbracket(_); end
  def on_redo; end
  def on_regexp_add(_, _); end
  def on_regexp_beg(_); end
  def on_regexp_end(_); end
  def on_regexp_literal(_, _); end
  def on_regexp_new; end
  def on_rescue(_, _, _, _); end
  def on_rescue_mod(_, _); end
  def on_rest_param(_); end
  def on_retry; end
  def on_return(_); end
  def on_return0; end
  def on_rparen(_); end
  def on_sclass(_, _); end
  def on_semicolon(_); end
  def on_sp(_); end
  def on_stmts_add(_, _); end
  def on_stmts_new; end
  def on_string_add(_, _); end
  def on_string_concat(_, _); end
  def on_string_content; end
  def on_string_dvar(_); end
  def on_string_embexpr(_); end
  def on_string_literal(_); end
  def on_super(_); end
  def on_symbeg(_); end
  def on_symbol(_); end
  def on_symbol_literal(_); end
  def on_symbols_add(_, _); end
  def on_symbols_beg(_); end
  def on_symbols_new; end
  def on_tlambda(_); end
  def on_tlambeg(_); end
  def on_top_const_field(_); end
  def on_top_const_ref(_); end
  def on_tstring_beg(_); end
  def on_tstring_content(_); end
  def on_tstring_end(_); end
  def on_unary(_, _); end
  def on_undef(_); end
  def on_unless(_, _, _); end
  def on_unless_mod(_, _); end
  def on_until(_, _); end
  def on_until_mod(_, _); end
  def on_var_alias(_, _); end
  def on_var_field(_); end
  def on_var_ref(_); end
  def on_vcall(_); end
  def on_void_stmt; end
  def on_when(_, _, _); end
  def on_while(_, _); end
  def on_while_mod(_, _); end
  def on_word_add(_, _); end
  def on_word_new; end
  def on_words_add(_, _); end
  def on_words_beg(_); end
  def on_words_new; end
  def on_words_sep(_); end
  def on_xstring_add(_, _); end
  def on_xstring_literal(_); end
  def on_xstring_new; end
  def on_yield(_); end
  def on_yield0; end
  def on_zsuper; end
  def result; end
  def trailing_comma?(left, right); end
  def visit_alias_global_variable_node_value(node); end
  def visit_arguments(elements); end
  def visit_begin_node_clauses(location, node, allow_newline); end
  def visit_body_node(location, node, allow_newline = T.unsafe(nil)); end
  def visit_call_node_arguments(arguments_node, block_node, trailing_comma); end
  def visit_constant_path_write_node_target(node); end
  def visit_destructured_parameter_node(node); end
  def visit_heredoc_node(parts, base); end
  def visit_heredoc_node_whitespace(parts); end
  def visit_heredoc_string_node(node); end
  def visit_heredoc_x_string_node(node); end
  def visit_multi_target_node_targets(lefts, rest, rights, skippable); end
  def visit_number_node(node); end
  def visit_pattern_node(node); end
  def visit_statements_node_body(body); end
  def visit_string_content(part); end
  def visit_token(token, allow_keywords = T.unsafe(nil)); end
  def visit_words_sep(opening_loc, previous, current); end
  def visit_write_value(node); end
  def void_stmt?(left, right, allow_newline); end
  def warn(fmt, *args); end
  def warning(fmt, *args); end

  class << self
    def lex(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
    def parse(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end
    def sexp(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
    def sexp_raw(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
  end
end

Prism::Translation::Ripper::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)
Prism::Translation::Ripper::EVENTS = T.let(T.unsafe(nil), Array)
Prism::Translation::Ripper::KEYWORDS = T.let(T.unsafe(nil), Array)
Prism::Translation::Ripper::PARSER_EVENTS = T.let(T.unsafe(nil), Array)
Prism::Translation::Ripper::PARSER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)
Prism::Translation::Ripper::SCANNER_EVENTS = T.let(T.unsafe(nil), Array)
Prism::Translation::Ripper::SCANNER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)

class Prism::Translation::Ripper::SexpBuilder < ::Prism::Translation::Ripper
  def error; end
  def on_BEGIN(*args); end
  def on_CHAR(tok); end
  def on_END(*args); end
  def on___end__(tok); end
  def on_alias(*args); end
  def on_alias_error(*args); end
  def on_aref(*args); end
  def on_aref_field(*args); end
  def on_arg_ambiguous(*args); end
  def on_arg_paren(*args); end
  def on_args_add(*args); end
  def on_args_add_block(*args); end
  def on_args_add_star(*args); end
  def on_args_forward(*args); end
  def on_args_new(*args); end
  def on_array(*args); end
  def on_aryptn(*args); end
  def on_assign(*args); end
  def on_assign_error(*args); end
  def on_assoc_new(*args); end
  def on_assoc_splat(*args); end
  def on_assoclist_from_args(*args); end
  def on_backref(tok); end
  def on_backtick(tok); end
  def on_bare_assoc_hash(*args); end
  def on_begin(*args); end
  def on_binary(*args); end
  def on_block_var(*args); end
  def on_blockarg(*args); end
  def on_bodystmt(*args); end
  def on_brace_block(*args); end
  def on_break(*args); end
  def on_call(*args); end
  def on_case(*args); end
  def on_class(*args); end
  def on_class_name_error(*args); end
  def on_comma(tok); end
  def on_command(*args); end
  def on_command_call(*args); end
  def on_comment(tok); end
  def on_const(tok); end
  def on_const_path_field(*args); end
  def on_const_path_ref(*args); end
  def on_const_ref(*args); end
  def on_cvar(tok); end
  def on_def(*args); end
  def on_defined(*args); end
  def on_defs(*args); end
  def on_do_block(*args); end
  def on_dot2(*args); end
  def on_dot3(*args); end
  def on_dyna_symbol(*args); end
  def on_else(*args); end
  def on_elsif(*args); end
  def on_embdoc(tok); end
  def on_embdoc_beg(tok); end
  def on_embdoc_end(tok); end
  def on_embexpr_beg(tok); end
  def on_embexpr_end(tok); end
  def on_embvar(tok); end
  def on_ensure(*args); end
  def on_excessed_comma(*args); end
  def on_fcall(*args); end
  def on_field(*args); end
  def on_float(tok); end
  def on_fndptn(*args); end
  def on_for(*args); end
  def on_gvar(tok); end
  def on_hash(*args); end
  def on_heredoc_beg(tok); end
  def on_heredoc_end(tok); end
  def on_hshptn(*args); end
  def on_ident(tok); end
  def on_if(*args); end
  def on_if_mod(*args); end
  def on_ifop(*args); end
  def on_ignored_nl(tok); end
  def on_ignored_sp(tok); end
  def on_imaginary(tok); end
  def on_in(*args); end
  def on_int(tok); end
  def on_ivar(tok); end
  def on_kw(tok); end
  def on_kwrest_param(*args); end
  def on_label(tok); end
  def on_label_end(tok); end
  def on_lambda(*args); end
  def on_lbrace(tok); end
  def on_lbracket(tok); end
  def on_lparen(tok); end
  def on_magic_comment(*args); end
  def on_massign(*args); end
  def on_method_add_arg(*args); end
  def on_method_add_block(*args); end
  def on_mlhs_add(*args); end
  def on_mlhs_add_post(*args); end
  def on_mlhs_add_star(*args); end
  def on_mlhs_new(*args); end
  def on_mlhs_paren(*args); end
  def on_module(*args); end
  def on_mrhs_add(*args); end
  def on_mrhs_add_star(*args); end
  def on_mrhs_new(*args); end
  def on_mrhs_new_from_args(*args); end
  def on_next(*args); end
  def on_nl(tok); end
  def on_nokw_param(*args); end
  def on_op(tok); end
  def on_opassign(*args); end
  def on_operator_ambiguous(*args); end
  def on_param_error(*args); end
  def on_params(*args); end
  def on_paren(*args); end
  def on_period(tok); end
  def on_program(*args); end
  def on_qsymbols_add(*args); end
  def on_qsymbols_beg(tok); end
  def on_qsymbols_new(*args); end
  def on_qwords_add(*args); end
  def on_qwords_beg(tok); end
  def on_qwords_new(*args); end
  def on_rational(tok); end
  def on_rbrace(tok); end
  def on_rbracket(tok); end
  def on_redo(*args); end
  def on_regexp_add(*args); end
  def on_regexp_beg(tok); end
  def on_regexp_end(tok); end
  def on_regexp_literal(*args); end
  def on_regexp_new(*args); end
  def on_rescue(*args); end
  def on_rescue_mod(*args); end
  def on_rest_param(*args); end
  def on_retry(*args); end
  def on_return(*args); end
  def on_return0(*args); end
  def on_rparen(tok); end
  def on_sclass(*args); end
  def on_semicolon(tok); end
  def on_sp(tok); end
  def on_stmts_add(*args); end
  def on_stmts_new(*args); end
  def on_string_add(*args); end
  def on_string_concat(*args); end
  def on_string_content(*args); end
  def on_string_dvar(*args); end
  def on_string_embexpr(*args); end
  def on_string_literal(*args); end
  def on_super(*args); end
  def on_symbeg(tok); end
  def on_symbol(*args); end
  def on_symbol_literal(*args); end
  def on_symbols_add(*args); end
  def on_symbols_beg(tok); end
  def on_symbols_new(*args); end
  def on_tlambda(tok); end
  def on_tlambeg(tok); end
  def on_top_const_field(*args); end
  def on_top_const_ref(*args); end
  def on_tstring_beg(tok); end
  def on_tstring_content(tok); end
  def on_tstring_end(tok); end
  def on_unary(*args); end
  def on_undef(*args); end
  def on_unless(*args); end
  def on_unless_mod(*args); end
  def on_until(*args); end
  def on_until_mod(*args); end
  def on_var_alias(*args); end
  def on_var_field(*args); end
  def on_var_ref(*args); end
  def on_vcall(*args); end
  def on_void_stmt(*args); end
  def on_when(*args); end
  def on_while(*args); end
  def on_while_mod(*args); end
  def on_word_add(*args); end
  def on_word_new(*args); end
  def on_words_add(*args); end
  def on_words_beg(tok); end
  def on_words_new(*args); end
  def on_words_sep(tok); end
  def on_xstring_add(*args); end
  def on_xstring_literal(*args); end
  def on_xstring_new(*args); end
  def on_yield(*args); end
  def on_yield0(*args); end
  def on_zsuper(*args); end

  private

  def compile_error(mesg); end
  def dedent_element(e, width); end
  def on_error(mesg); end
  def on_heredoc_dedent(val, width); end
  def on_parse_error(mesg); end
end

class Prism::Translation::Ripper::SexpBuilderPP < ::Prism::Translation::Ripper::SexpBuilder
  private

  def _dispatch_event_new; end
  def _dispatch_event_push(list, item); end
  def on_args_add(list, item); end
  def on_args_new; end
  def on_heredoc_dedent(val, width); end
  def on_mlhs_add(list, item); end
  def on_mlhs_add_post(list, post); end
  def on_mlhs_add_star(list, star); end
  def on_mlhs_new; end
  def on_mlhs_paren(list); end
  def on_mrhs_add(list, item); end
  def on_mrhs_new; end
  def on_qsymbols_add(list, item); end
  def on_qsymbols_new; end
  def on_qwords_add(list, item); end
  def on_qwords_new; end
  def on_regexp_add(list, item); end
  def on_regexp_new; end
  def on_stmts_add(list, item); end
  def on_stmts_new; end
  def on_string_add(list, item); end
  def on_symbols_add(list, item); end
  def on_symbols_new; end
  def on_word_add(list, item); end
  def on_word_new; end
  def on_words_add(list, item); end
  def on_words_new; end
  def on_xstring_add(list, item); end
  def on_xstring_new; end
end

class Prism::Translation::RubyParser
  def parse(source, filepath = T.unsafe(nil)); end
  def parse_file(filepath); end

  private

  def translate(result, filepath); end

  class << self
    def parse(source, filepath = T.unsafe(nil)); end
    def parse_file(filepath); end
  end
end

class Prism::Translation::RubyParser::Compiler < ::Prism::Compiler
  def initialize(file, in_def: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  def file; end
  def in_def; end
  def in_pattern; end
  def visit_alias_global_variable_node(node); end
  def visit_alias_method_node(node); end
  def visit_alternation_pattern_node(node); end
  def visit_and_node(node); end
  def visit_arguments_node(node); end
  def visit_array_node(node); end
  def visit_array_pattern_node(node); end
  def visit_assoc_node(node); end
  def visit_assoc_splat_node(node); end
  def visit_back_reference_read_node(node); end
  def visit_begin_node(node); end
  def visit_block_argument_node(node); end
  def visit_block_local_variable_node(node); end
  def visit_block_node(node); end
  def visit_block_parameter_node(node); end
  def visit_block_parameters_node(node); end
  def visit_break_node(node); end
  def visit_call_and_write_node(node); end
  def visit_call_node(node); end
  def visit_call_operator_write_node(node); end
  def visit_call_or_write_node(node); end
  def visit_call_target_node(node); end
  def visit_capture_pattern_node(node); end
  def visit_case_match_node(node); end
  def visit_case_node(node); end
  def visit_class_node(node); end
  def visit_class_variable_and_write_node(node); end
  def visit_class_variable_operator_write_node(node); end
  def visit_class_variable_or_write_node(node); end
  def visit_class_variable_read_node(node); end
  def visit_class_variable_target_node(node); end
  def visit_class_variable_write_node(node); end
  def visit_constant_and_write_node(node); end
  def visit_constant_operator_write_node(node); end
  def visit_constant_or_write_node(node); end
  def visit_constant_path_and_write_node(node); end
  def visit_constant_path_node(node); end
  def visit_constant_path_operator_write_node(node); end
  def visit_constant_path_or_write_node(node); end
  def visit_constant_path_target_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_read_node(node); end
  def visit_constant_target_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_defined_node(node); end
  def visit_else_node(node); end
  def visit_embedded_statements_node(node); end
  def visit_embedded_variable_node(node); end
  def visit_ensure_node(node); end
  def visit_false_node(node); end
  def visit_find_pattern_node(node); end
  def visit_flip_flop_node(node); end
  def visit_float_node(node); end
  def visit_for_node(node); end
  def visit_forwarding_arguments_node(node); end
  def visit_forwarding_parameter_node(node); end
  def visit_forwarding_super_node(node); end
  def visit_global_variable_and_write_node(node); end
  def visit_global_variable_operator_write_node(node); end
  def visit_global_variable_or_write_node(node); end
  def visit_global_variable_read_node(node); end
  def visit_global_variable_target_node(node); end
  def visit_global_variable_write_node(node); end
  def visit_hash_node(node); end
  def visit_hash_pattern_node(node); end
  def visit_if_node(node); end
  def visit_imaginary_node(node); end
  def visit_implicit_node(node); end
  def visit_implicit_rest_node(node); end
  def visit_in_node(node); end
  def visit_index_and_write_node(node); end
  def visit_index_operator_write_node(node); end
  def visit_index_or_write_node(node); end
  def visit_index_target_node(node); end
  def visit_instance_variable_and_write_node(node); end
  def visit_instance_variable_operator_write_node(node); end
  def visit_instance_variable_or_write_node(node); end
  def visit_instance_variable_read_node(node); end
  def visit_instance_variable_target_node(node); end
  def visit_instance_variable_write_node(node); end
  def visit_integer_node(node); end
  def visit_interpolated_match_last_line_node(node); end
  def visit_interpolated_regular_expression_node(node); end
  def visit_interpolated_string_node(node); end
  def visit_interpolated_symbol_node(node); end
  def visit_interpolated_x_string_node(node); end
  def visit_it_local_variable_read_node(node); end
  def visit_keyword_hash_node(node); end
  def visit_keyword_rest_parameter_node(node); end
  def visit_lambda_node(node); end
  def visit_local_variable_and_write_node(node); end
  def visit_local_variable_operator_write_node(node); end
  def visit_local_variable_or_write_node(node); end
  def visit_local_variable_read_node(node); end
  def visit_local_variable_target_node(node); end
  def visit_local_variable_write_node(node); end
  def visit_match_last_line_node(node); end
  def visit_match_predicate_node(node); end
  def visit_match_required_node(node); end
  def visit_match_write_node(node); end
  def visit_missing_node(node); end
  def visit_module_node(node); end
  def visit_multi_target_node(node); end
  def visit_multi_write_node(node); end
  def visit_next_node(node); end
  def visit_nil_node(node); end
  def visit_no_keywords_parameter_node(node); end
  def visit_numbered_parameters_node(node); end
  def visit_numbered_reference_read_node(node); end
  def visit_optional_keyword_parameter_node(node); end
  def visit_optional_parameter_node(node); end
  def visit_or_node(node); end
  def visit_parameters_node(node); end
  def visit_parentheses_node(node); end
  def visit_pinned_expression_node(node); end
  def visit_pinned_variable_node(node); end
  def visit_post_execution_node(node); end
  def visit_pre_execution_node(node); end
  def visit_program_node(node); end
  def visit_range_node(node); end
  def visit_rational_node(node); end
  def visit_redo_node(node); end
  def visit_regular_expression_node(node); end
  def visit_required_keyword_parameter_node(node); end
  def visit_required_parameter_node(node); end
  def visit_rescue_modifier_node(node); end
  def visit_rescue_node(node); end
  def visit_rest_parameter_node(node); end
  def visit_retry_node(node); end
  def visit_return_node(node); end
  def visit_self_node(node); end
  def visit_shareable_constant_node(node); end
  def visit_singleton_class_node(node); end
  def visit_source_encoding_node(node); end
  def visit_source_file_node(node); end
  def visit_source_line_node(node); end
  def visit_splat_node(node); end
  def visit_statements_node(node); end
  def visit_string_node(node); end
  def visit_super_node(node); end
  def visit_symbol_node(node); end
  def visit_true_node(node); end
  def visit_undef_node(node); end
  def visit_unless_node(node); end
  def visit_until_node(node); end
  def visit_when_node(node); end
  def visit_while_node(node); end
  def visit_x_string_node(node); end
  def visit_yield_node(node); end

  private

  def class_variable_write_type; end
  def copy_compiler(in_def: T.unsafe(nil), in_pattern: T.unsafe(nil)); end
  def op_asgn?(node); end
  def op_asgn_type(node, type); end
  def s(node, *arguments); end
  def visit_block(node, sexp, block); end
  def visit_destructured_parameter(node); end
  def visit_interpolated_parts(parts); end
  def visit_pattern_constant(node); end
  def visit_range_bounds_node(node); end
  def visit_write_value(node); end
end

class Prism::TrueNode < ::Prism::Node
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::TrueNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::UndefNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      names: T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, names, keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      names: T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      keyword_loc: Prism::Location
    ).returns(Prism::UndefNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), names: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)]) }
  def names; end

  def save_keyword_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::UnlessNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      else_clause: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, predicate, then_keyword_loc, statements, else_clause, end_keyword_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  def consequent; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      else_clause: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::UnlessNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), else_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def newline_flag!(lines); end

  sig { returns(Prism::Node) }
  def predicate; end

  def save_end_keyword_loc(repository); end
  def save_keyword_loc(repository); end
  def save_then_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(String)) }
  def then_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::UntilNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, do_keyword_loc, closing_loc, predicate, statements); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def begin_modifier?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::UntilNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def do_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def newline_flag!(lines); end

  sig { returns(Prism::Node) }
  def predicate; end

  def save_closing_loc(repository); end
  def save_do_keyword_loc(repository); end
  def save_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

Prism::VERSION = T.let(T.unsafe(nil), String)

class Prism::Visitor < ::Prism::BasicVisitor
  sig { params(node: Prism::AliasGlobalVariableNode).void }
  def visit_alias_global_variable_node(node); end

  sig { params(node: Prism::AliasMethodNode).void }
  def visit_alias_method_node(node); end

  sig { params(node: Prism::AlternationPatternNode).void }
  def visit_alternation_pattern_node(node); end

  sig { params(node: Prism::AndNode).void }
  def visit_and_node(node); end

  sig { params(node: Prism::ArgumentsNode).void }
  def visit_arguments_node(node); end

  sig { params(node: Prism::ArrayNode).void }
  def visit_array_node(node); end

  sig { params(node: Prism::ArrayPatternNode).void }
  def visit_array_pattern_node(node); end

  sig { params(node: Prism::AssocNode).void }
  def visit_assoc_node(node); end

  sig { params(node: Prism::AssocSplatNode).void }
  def visit_assoc_splat_node(node); end

  sig { params(node: Prism::BackReferenceReadNode).void }
  def visit_back_reference_read_node(node); end

  sig { params(node: Prism::BeginNode).void }
  def visit_begin_node(node); end

  sig { params(node: Prism::BlockArgumentNode).void }
  def visit_block_argument_node(node); end

  sig { params(node: Prism::BlockLocalVariableNode).void }
  def visit_block_local_variable_node(node); end

  sig { params(node: Prism::BlockNode).void }
  def visit_block_node(node); end

  sig { params(node: Prism::BlockParameterNode).void }
  def visit_block_parameter_node(node); end

  sig { params(node: Prism::BlockParametersNode).void }
  def visit_block_parameters_node(node); end

  sig { params(node: Prism::BreakNode).void }
  def visit_break_node(node); end

  sig { params(node: Prism::CallAndWriteNode).void }
  def visit_call_and_write_node(node); end

  sig { params(node: Prism::CallNode).void }
  def visit_call_node(node); end

  sig { params(node: Prism::CallOperatorWriteNode).void }
  def visit_call_operator_write_node(node); end

  sig { params(node: Prism::CallOrWriteNode).void }
  def visit_call_or_write_node(node); end

  sig { params(node: Prism::CallTargetNode).void }
  def visit_call_target_node(node); end

  sig { params(node: Prism::CapturePatternNode).void }
  def visit_capture_pattern_node(node); end

  sig { params(node: Prism::CaseMatchNode).void }
  def visit_case_match_node(node); end

  sig { params(node: Prism::CaseNode).void }
  def visit_case_node(node); end

  sig { params(node: Prism::ClassNode).void }
  def visit_class_node(node); end

  sig { params(node: Prism::ClassVariableAndWriteNode).void }
  def visit_class_variable_and_write_node(node); end

  sig { params(node: Prism::ClassVariableOperatorWriteNode).void }
  def visit_class_variable_operator_write_node(node); end

  sig { params(node: Prism::ClassVariableOrWriteNode).void }
  def visit_class_variable_or_write_node(node); end

  sig { params(node: Prism::ClassVariableReadNode).void }
  def visit_class_variable_read_node(node); end

  sig { params(node: Prism::ClassVariableTargetNode).void }
  def visit_class_variable_target_node(node); end

  sig { params(node: Prism::ClassVariableWriteNode).void }
  def visit_class_variable_write_node(node); end

  sig { params(node: Prism::ConstantAndWriteNode).void }
  def visit_constant_and_write_node(node); end

  sig { params(node: Prism::ConstantOperatorWriteNode).void }
  def visit_constant_operator_write_node(node); end

  sig { params(node: Prism::ConstantOrWriteNode).void }
  def visit_constant_or_write_node(node); end

  sig { params(node: Prism::ConstantPathAndWriteNode).void }
  def visit_constant_path_and_write_node(node); end

  sig { params(node: Prism::ConstantPathNode).void }
  def visit_constant_path_node(node); end

  sig { params(node: Prism::ConstantPathOperatorWriteNode).void }
  def visit_constant_path_operator_write_node(node); end

  sig { params(node: Prism::ConstantPathOrWriteNode).void }
  def visit_constant_path_or_write_node(node); end

  sig { params(node: Prism::ConstantPathTargetNode).void }
  def visit_constant_path_target_node(node); end

  sig { params(node: Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  sig { params(node: Prism::ConstantReadNode).void }
  def visit_constant_read_node(node); end

  sig { params(node: Prism::ConstantTargetNode).void }
  def visit_constant_target_node(node); end

  sig { params(node: Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  sig { params(node: Prism::DefNode).void }
  def visit_def_node(node); end

  sig { params(node: Prism::DefinedNode).void }
  def visit_defined_node(node); end

  sig { params(node: Prism::ElseNode).void }
  def visit_else_node(node); end

  sig { params(node: Prism::EmbeddedStatementsNode).void }
  def visit_embedded_statements_node(node); end

  sig { params(node: Prism::EmbeddedVariableNode).void }
  def visit_embedded_variable_node(node); end

  sig { params(node: Prism::EnsureNode).void }
  def visit_ensure_node(node); end

  sig { params(node: Prism::FalseNode).void }
  def visit_false_node(node); end

  sig { params(node: Prism::FindPatternNode).void }
  def visit_find_pattern_node(node); end

  sig { params(node: Prism::FlipFlopNode).void }
  def visit_flip_flop_node(node); end

  sig { params(node: Prism::FloatNode).void }
  def visit_float_node(node); end

  sig { params(node: Prism::ForNode).void }
  def visit_for_node(node); end

  sig { params(node: Prism::ForwardingArgumentsNode).void }
  def visit_forwarding_arguments_node(node); end

  sig { params(node: Prism::ForwardingParameterNode).void }
  def visit_forwarding_parameter_node(node); end

  sig { params(node: Prism::ForwardingSuperNode).void }
  def visit_forwarding_super_node(node); end

  sig { params(node: Prism::GlobalVariableAndWriteNode).void }
  def visit_global_variable_and_write_node(node); end

  sig { params(node: Prism::GlobalVariableOperatorWriteNode).void }
  def visit_global_variable_operator_write_node(node); end

  sig { params(node: Prism::GlobalVariableOrWriteNode).void }
  def visit_global_variable_or_write_node(node); end

  sig { params(node: Prism::GlobalVariableReadNode).void }
  def visit_global_variable_read_node(node); end

  sig { params(node: Prism::GlobalVariableTargetNode).void }
  def visit_global_variable_target_node(node); end

  sig { params(node: Prism::GlobalVariableWriteNode).void }
  def visit_global_variable_write_node(node); end

  sig { params(node: Prism::HashNode).void }
  def visit_hash_node(node); end

  sig { params(node: Prism::HashPatternNode).void }
  def visit_hash_pattern_node(node); end

  sig { params(node: Prism::IfNode).void }
  def visit_if_node(node); end

  sig { params(node: Prism::ImaginaryNode).void }
  def visit_imaginary_node(node); end

  sig { params(node: Prism::ImplicitNode).void }
  def visit_implicit_node(node); end

  sig { params(node: Prism::ImplicitRestNode).void }
  def visit_implicit_rest_node(node); end

  sig { params(node: Prism::InNode).void }
  def visit_in_node(node); end

  sig { params(node: Prism::IndexAndWriteNode).void }
  def visit_index_and_write_node(node); end

  sig { params(node: Prism::IndexOperatorWriteNode).void }
  def visit_index_operator_write_node(node); end

  sig { params(node: Prism::IndexOrWriteNode).void }
  def visit_index_or_write_node(node); end

  sig { params(node: Prism::IndexTargetNode).void }
  def visit_index_target_node(node); end

  sig { params(node: Prism::InstanceVariableAndWriteNode).void }
  def visit_instance_variable_and_write_node(node); end

  sig { params(node: Prism::InstanceVariableOperatorWriteNode).void }
  def visit_instance_variable_operator_write_node(node); end

  sig { params(node: Prism::InstanceVariableOrWriteNode).void }
  def visit_instance_variable_or_write_node(node); end

  sig { params(node: Prism::InstanceVariableReadNode).void }
  def visit_instance_variable_read_node(node); end

  sig { params(node: Prism::InstanceVariableTargetNode).void }
  def visit_instance_variable_target_node(node); end

  sig { params(node: Prism::InstanceVariableWriteNode).void }
  def visit_instance_variable_write_node(node); end

  sig { params(node: Prism::IntegerNode).void }
  def visit_integer_node(node); end

  sig { params(node: Prism::InterpolatedMatchLastLineNode).void }
  def visit_interpolated_match_last_line_node(node); end

  sig { params(node: Prism::InterpolatedRegularExpressionNode).void }
  def visit_interpolated_regular_expression_node(node); end

  sig { params(node: Prism::InterpolatedStringNode).void }
  def visit_interpolated_string_node(node); end

  sig { params(node: Prism::InterpolatedSymbolNode).void }
  def visit_interpolated_symbol_node(node); end

  sig { params(node: Prism::InterpolatedXStringNode).void }
  def visit_interpolated_x_string_node(node); end

  sig { params(node: Prism::ItLocalVariableReadNode).void }
  def visit_it_local_variable_read_node(node); end

  sig { params(node: Prism::ItParametersNode).void }
  def visit_it_parameters_node(node); end

  sig { params(node: Prism::KeywordHashNode).void }
  def visit_keyword_hash_node(node); end

  sig { params(node: Prism::KeywordRestParameterNode).void }
  def visit_keyword_rest_parameter_node(node); end

  sig { params(node: Prism::LambdaNode).void }
  def visit_lambda_node(node); end

  sig { params(node: Prism::LocalVariableAndWriteNode).void }
  def visit_local_variable_and_write_node(node); end

  sig { params(node: Prism::LocalVariableOperatorWriteNode).void }
  def visit_local_variable_operator_write_node(node); end

  sig { params(node: Prism::LocalVariableOrWriteNode).void }
  def visit_local_variable_or_write_node(node); end

  sig { params(node: Prism::LocalVariableReadNode).void }
  def visit_local_variable_read_node(node); end

  sig { params(node: Prism::LocalVariableTargetNode).void }
  def visit_local_variable_target_node(node); end

  sig { params(node: Prism::LocalVariableWriteNode).void }
  def visit_local_variable_write_node(node); end

  sig { params(node: Prism::MatchLastLineNode).void }
  def visit_match_last_line_node(node); end

  sig { params(node: Prism::MatchPredicateNode).void }
  def visit_match_predicate_node(node); end

  sig { params(node: Prism::MatchRequiredNode).void }
  def visit_match_required_node(node); end

  sig { params(node: Prism::MatchWriteNode).void }
  def visit_match_write_node(node); end

  sig { params(node: Prism::MissingNode).void }
  def visit_missing_node(node); end

  sig { params(node: Prism::ModuleNode).void }
  def visit_module_node(node); end

  sig { params(node: Prism::MultiTargetNode).void }
  def visit_multi_target_node(node); end

  sig { params(node: Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  sig { params(node: Prism::NextNode).void }
  def visit_next_node(node); end

  sig { params(node: Prism::NilNode).void }
  def visit_nil_node(node); end

  sig { params(node: Prism::NoKeywordsParameterNode).void }
  def visit_no_keywords_parameter_node(node); end

  sig { params(node: Prism::NumberedParametersNode).void }
  def visit_numbered_parameters_node(node); end

  sig { params(node: Prism::NumberedReferenceReadNode).void }
  def visit_numbered_reference_read_node(node); end

  sig { params(node: Prism::OptionalKeywordParameterNode).void }
  def visit_optional_keyword_parameter_node(node); end

  sig { params(node: Prism::OptionalParameterNode).void }
  def visit_optional_parameter_node(node); end

  sig { params(node: Prism::OrNode).void }
  def visit_or_node(node); end

  sig { params(node: Prism::ParametersNode).void }
  def visit_parameters_node(node); end

  sig { params(node: Prism::ParenthesesNode).void }
  def visit_parentheses_node(node); end

  sig { params(node: Prism::PinnedExpressionNode).void }
  def visit_pinned_expression_node(node); end

  sig { params(node: Prism::PinnedVariableNode).void }
  def visit_pinned_variable_node(node); end

  sig { params(node: Prism::PostExecutionNode).void }
  def visit_post_execution_node(node); end

  sig { params(node: Prism::PreExecutionNode).void }
  def visit_pre_execution_node(node); end

  sig { params(node: Prism::ProgramNode).void }
  def visit_program_node(node); end

  sig { params(node: Prism::RangeNode).void }
  def visit_range_node(node); end

  sig { params(node: Prism::RationalNode).void }
  def visit_rational_node(node); end

  sig { params(node: Prism::RedoNode).void }
  def visit_redo_node(node); end

  sig { params(node: Prism::RegularExpressionNode).void }
  def visit_regular_expression_node(node); end

  sig { params(node: Prism::RequiredKeywordParameterNode).void }
  def visit_required_keyword_parameter_node(node); end

  sig { params(node: Prism::RequiredParameterNode).void }
  def visit_required_parameter_node(node); end

  sig { params(node: Prism::RescueModifierNode).void }
  def visit_rescue_modifier_node(node); end

  sig { params(node: Prism::RescueNode).void }
  def visit_rescue_node(node); end

  sig { params(node: Prism::RestParameterNode).void }
  def visit_rest_parameter_node(node); end

  sig { params(node: Prism::RetryNode).void }
  def visit_retry_node(node); end

  sig { params(node: Prism::ReturnNode).void }
  def visit_return_node(node); end

  sig { params(node: Prism::SelfNode).void }
  def visit_self_node(node); end

  sig { params(node: Prism::ShareableConstantNode).void }
  def visit_shareable_constant_node(node); end

  sig { params(node: Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  sig { params(node: Prism::SourceEncodingNode).void }
  def visit_source_encoding_node(node); end

  sig { params(node: Prism::SourceFileNode).void }
  def visit_source_file_node(node); end

  sig { params(node: Prism::SourceLineNode).void }
  def visit_source_line_node(node); end

  sig { params(node: Prism::SplatNode).void }
  def visit_splat_node(node); end

  sig { params(node: Prism::StatementsNode).void }
  def visit_statements_node(node); end

  sig { params(node: Prism::StringNode).void }
  def visit_string_node(node); end

  sig { params(node: Prism::SuperNode).void }
  def visit_super_node(node); end

  sig { params(node: Prism::SymbolNode).void }
  def visit_symbol_node(node); end

  sig { params(node: Prism::TrueNode).void }
  def visit_true_node(node); end

  sig { params(node: Prism::UndefNode).void }
  def visit_undef_node(node); end

  sig { params(node: Prism::UnlessNode).void }
  def visit_unless_node(node); end

  sig { params(node: Prism::UntilNode).void }
  def visit_until_node(node); end

  sig { params(node: Prism::WhenNode).void }
  def visit_when_node(node); end

  sig { params(node: Prism::WhileNode).void }
  def visit_while_node(node); end

  sig { params(node: Prism::XStringNode).void }
  def visit_x_string_node(node); end

  sig { params(node: Prism::YieldNode).void }
  def visit_yield_node(node); end
end

class Prism::WhenNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, conditions, then_keyword_loc, statements); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhenNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def save_keyword_loc(repository); end
  def save_then_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(String)) }
  def then_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::WhileNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, do_keyword_loc, closing_loc, predicate, statements); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def begin_modifier?; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhileNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def do_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  def newline_flag!(lines); end

  sig { returns(Prism::Node) }
  def predicate; end

  def save_closing_loc(repository); end
  def save_do_keyword_loc(repository); end
  def save_keyword_loc(repository); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end

class Prism::XStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::XStringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def save_closing_loc(repository); end
  def save_content_loc(repository); end
  def save_opening_loc(repository); end

  sig { returns(Prism::InterpolatedXStringNode) }
  def to_interpolated; end

  sig { override.returns(Symbol) }
  def type; end

  sig { returns(String) }
  def unescaped; end

  class << self
    def type; end
  end
end

class Prism::YieldNode < ::Prism::Node
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, lparen_loc, arguments, rparen_loc); end

  def ===(other); end

  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::YieldNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { override.returns(String) }
  def inspect; end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  def save_keyword_loc(repository); end
  def save_lparen_loc(repository); end
  def save_rparen_loc(repository); end

  sig { override.returns(Symbol) }
  def type; end

  class << self
    def type; end
  end
end
