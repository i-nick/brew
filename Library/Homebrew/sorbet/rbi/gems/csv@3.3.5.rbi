# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `csv` gem.
# Please instead update this file by running `bin/tapioca gem csv`.


class Array
  include ::Enumerable

  def to_csv(**options); end
end

class CSV
  include ::Enumerable
  extend ::Forwardable

  def initialize(data, col_sep: T.unsafe(nil), row_sep: T.unsafe(nil), quote_char: T.unsafe(nil), field_size_limit: T.unsafe(nil), max_field_size: T.unsafe(nil), converters: T.unsafe(nil), unconverted_fields: T.unsafe(nil), headers: T.unsafe(nil), return_headers: T.unsafe(nil), write_headers: T.unsafe(nil), header_converters: T.unsafe(nil), skip_blanks: T.unsafe(nil), force_quotes: T.unsafe(nil), skip_lines: T.unsafe(nil), liberal_parsing: T.unsafe(nil), internal_encoding: T.unsafe(nil), external_encoding: T.unsafe(nil), encoding: T.unsafe(nil), nil_value: T.unsafe(nil), empty_value: T.unsafe(nil), strip: T.unsafe(nil), quote_empty: T.unsafe(nil), write_converters: T.unsafe(nil), write_nil_value: T.unsafe(nil), write_empty_value: T.unsafe(nil)); end

  def <<(row); end
  def add_row(row); end
  def binmode(*args, **_arg1, &block); end
  def binmode?; end
  def close(*args, **_arg1, &block); end
  def close_read(*args, **_arg1, &block); end
  def close_write(*args, **_arg1, &block); end
  def closed?(*args, **_arg1, &block); end
  def col_sep; end
  def convert(name = T.unsafe(nil), &converter); end
  def converters; end
  def each(&block); end
  def encoding; end
  def eof; end
  def eof?; end
  def external_encoding(*args, **_arg1, &block); end
  def fcntl(*args, **_arg1, &block); end
  def field_size_limit; end
  def fileno(*args, **_arg1, &block); end
  def flock(*args); end
  def flush(*args, **_arg1, &block); end
  def force_quotes?; end
  def fsync(*args, **_arg1, &block); end
  def gets; end
  def header_convert(name = T.unsafe(nil), &converter); end
  def header_converters; end
  def header_row?; end
  def headers; end
  def inspect; end
  def internal_encoding(*args, **_arg1, &block); end
  def ioctl(*args); end
  def isatty(*args, **_arg1, &block); end
  def liberal_parsing?; end
  def line; end
  def lineno; end
  def max_field_size; end
  def path; end
  def pid(*args, **_arg1, &block); end
  def pos(*args, **_arg1, &block); end
  def pos=(*args, **_arg1, &block); end
  def puts(row); end
  def quote_char; end
  def read; end
  def readline; end
  def readlines; end
  def reopen(*args, **_arg1, &block); end
  def return_headers?; end
  def rewind; end
  def row_sep; end
  def seek(*args, **_arg1, &block); end
  def shift; end
  def skip_blanks?; end
  def skip_lines; end
  def stat(*args); end
  def string(*args, **_arg1, &block); end
  def sync(*args, **_arg1, &block); end
  def sync=(*args, **_arg1, &block); end
  def tell(*args, **_arg1, &block); end
  def to_i; end
  def to_io; end
  def truncate(*args, **_arg1, &block); end
  def tty?(*args, **_arg1, &block); end
  def unconverted_fields?; end
  def write_headers?; end

  private

  def build_fields_converter(initial_converters, options); end
  def build_header_fields_converter; end
  def build_parser_fields_converter; end
  def build_writer_fields_converter; end
  def convert_fields(fields, headers = T.unsafe(nil)); end
  def determine_encoding(encoding, internal_encoding); end
  def header_fields_converter; end
  def normalize_converters(converters); end
  def parser; end
  def parser_enumerator; end
  def parser_fields_converter; end
  def parser_options; end
  def raw_encoding; end
  def writer; end
  def writer_fields_converter; end
  def writer_options; end

  class << self
    def filter(input = T.unsafe(nil), output = T.unsafe(nil), **options); end
    def foreach(path, mode = T.unsafe(nil), **options, &block); end
    def generate(str = T.unsafe(nil), **options); end
    def generate_line(row, **options); end
    def generate_lines(rows, **options); end
    def instance(data = T.unsafe(nil), **options); end
    def open(filename_or_io, mode = T.unsafe(nil), **options); end
    def parse(str, **options, &block); end
    def parse_line(line, **options); end
    def read(path, **options); end
    def readlines(path, **options); end
    def table(path, **options); end

    private

    def create_stringio(str, mode, opts); end
    def may_enable_bom_detection_automatically(filename_or_io, mode, options, file_opts); end
  end
end

CSV::ConverterEncoding = T.let(T.unsafe(nil), Encoding)
CSV::DateMatcher = T.let(T.unsafe(nil), Regexp)
CSV::DateTimeMatcher = T.let(T.unsafe(nil), Regexp)

class CSV::FieldInfo < ::Struct
  def header; end
  def header=(_); end
  def index; end
  def index=(_); end
  def line; end
  def line=(_); end
  def quoted?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class CSV::FieldsConverter
  include ::Enumerable

  def initialize(options = T.unsafe(nil)); end

  def add_converter(name = T.unsafe(nil), &converter); end
  def convert(fields, headers, lineno, quoted_fields = T.unsafe(nil)); end
  def each(&block); end
  def empty?; end

  private

  def builtin_converters; end
  def need_convert?; end
  def need_static_convert?; end
end

CSV::FieldsConverter::NO_QUOTED_FIELDS = T.let(T.unsafe(nil), Array)
CSV::HeaderConverters = T.let(T.unsafe(nil), Hash)

module CSV::InputRecordSeparator
  class << self
    def value; end
  end
end

class CSV::InvalidEncodingError < ::CSV::MalformedCSVError
  def initialize(encoding, line_number); end

  def encoding; end
end

class CSV::MalformedCSVError < ::RuntimeError
  def initialize(message, line_number); end

  def line_number; end
  def lineno; end
end

class CSV::Parser
  def initialize(input, options); end

  def column_separator; end
  def field_size_limit; end
  def header_row?; end
  def headers; end
  def liberal_parsing?; end
  def line; end
  def lineno; end
  def max_field_size; end
  def parse(&block); end
  def quote_character; end
  def return_headers?; end
  def row_separator; end
  def skip_blanks?; end
  def skip_lines; end
  def unconverted_fields?; end
  def use_headers?; end

  private

  def add_unconverted_fields(row, fields); end
  def adjust_headers(headers, quoted_fields); end
  def build_scanner; end
  def detect_row_separator(sample, cr, lf); end
  def emit_row(row, quoted_fields = T.unsafe(nil), &block); end
  def ignore_broken_line; end
  def last_line; end
  def may_quoted?; end
  def parse_column_end; end
  def parse_column_value; end
  def parse_headers(row); end
  def parse_no_quote(&block); end
  def parse_quotable_loose(&block); end
  def parse_quotable_robust(&block); end
  def parse_quoted_column_value; end
  def parse_row_end; end
  def parse_unquoted_column_value; end
  def prepare; end
  def prepare_backslash; end
  def prepare_header; end
  def prepare_line; end
  def prepare_parser; end
  def prepare_quote_character; end
  def prepare_quoted; end
  def prepare_separators; end
  def prepare_skip_lines; end
  def prepare_strip; end
  def prepare_unquoted; end
  def prepare_variable; end
  def resolve_row_separator(separator); end
  def skip_line?(line); end
  def skip_needless_lines; end
  def start_row; end
  def strip_value(value); end
  def validate_field_size(field); end
  def validate_strip_and_col_sep_options; end

  class << self
    def eof?(input); end
  end
end

class CSV::Parser::InputsScanner
  def initialize(inputs, encoding, row_separator, chunk_size: T.unsafe(nil)); end

  def check(pattern); end
  def each_line(row_separator); end
  def eos?; end
  def keep_back; end
  def keep_drop; end
  def keep_end; end
  def keep_start; end
  def rest; end
  def scan(pattern); end
  def scan_all(pattern); end

  private

  def adjust_last_keep; end
  def read_chunk; end
  def trace(*args); end
end

class CSV::Parser::InvalidEncoding < ::StandardError; end
CSV::Parser::SCANNER_TEST = T.let(T.unsafe(nil), FalseClass)
CSV::Parser::STRING_SCANNER_SCAN_ACCEPT_STRING = T.let(T.unsafe(nil), TrueClass)

class CSV::Parser::Scanner < ::StringScanner
  def initialize(*args); end

  def each_line(row_separator); end
  def keep_back; end
  def keep_drop; end
  def keep_end; end
  def keep_start; end
  def scan_all(_arg0); end
end

class CSV::Parser::UnexpectedError < ::StandardError; end

class CSV::Parser::UnoptimizedStringIO
  def initialize(string); end

  def each_line(*args, &block); end
  def eof?; end
  def gets(*args); end
end

class CSV::Row
  include ::Enumerable
  extend ::Forwardable

  def initialize(headers, fields, header_row = T.unsafe(nil)); end

  def <<(arg); end
  def ==(other); end
  def [](header_or_index, minimum_index = T.unsafe(nil)); end
  def []=(*args); end
  def deconstruct; end
  def deconstruct_keys(keys); end
  def delete(header_or_index, minimum_index = T.unsafe(nil)); end
  def delete_if(&block); end
  def dig(index_or_header, *indexes); end
  def each(&block); end
  def each_pair(&block); end
  def empty?(*args, **_arg1, &block); end
  def fetch(header, *varargs); end
  def field(header_or_index, minimum_index = T.unsafe(nil)); end
  def field?(data); end
  def field_row?; end
  def fields(*headers_and_or_indices); end
  def has_key?(header); end
  def header?(header); end
  def header_row?; end
  def headers; end
  def include?(header); end
  def index(header, minimum_index = T.unsafe(nil)); end
  def inspect; end
  def key?(header); end
  def length(*args, **_arg1, &block); end
  def member?(header); end
  def push(*args); end
  def size(*args, **_arg1, &block); end
  def to_ary(*_arg0); end
  def to_csv(**options); end
  def to_h; end
  def to_hash; end
  def to_s(**options); end
  def values_at(*headers_and_or_indices); end

  protected

  def row; end

  private

  def initialize_copy(other); end
end

class CSV::TSV < ::CSV
  def initialize(data, **options); end
end

class CSV::Table
  include ::Enumerable
  extend ::Forwardable

  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def <<(row_or_array); end
  def ==(other); end
  def [](index_or_header); end
  def []=(index_or_header, value); end
  def by_col; end
  def by_col!; end
  def by_col_or_row; end
  def by_col_or_row!; end
  def by_row; end
  def by_row!; end
  def delete(*indexes_or_headers); end
  def delete_if(&block); end
  def dig(index_or_header, *index_or_headers); end
  def each(&block); end
  def empty?(*args, **_arg1, &block); end
  def headers; end
  def inspect; end
  def length(*args, **_arg1, &block); end
  def mode; end
  def push(*rows); end
  def size(*args, **_arg1, &block); end
  def to_a; end
  def to_csv(write_headers: T.unsafe(nil), limit: T.unsafe(nil), **options); end
  def to_s(write_headers: T.unsafe(nil), limit: T.unsafe(nil), **options); end
  def values_at(*indices_or_headers); end

  protected

  def table; end
end

class CSV::Writer
  def initialize(output, options); end

  def <<(row); end
  def headers; end
  def lineno; end
  def rewind; end

  private

  def prepare; end
  def prepare_force_quotes_fields(force_quotes); end
  def prepare_format; end
  def prepare_header; end
  def prepare_output; end
  def quote(field, i); end
  def quote_field(field); end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  def CSV(*args, **options, &block); end
end

class String
  include ::Comparable

  def parse_csv(**options); end
end
